// Code generated by ent, DO NOT EDIT.

package pjsk

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"haruki-database/database/schema/pjsk/migrate"

	"haruki-database/database/schema/pjsk/alias"
	"haruki-database/database/schema/pjsk/aliasadmin"
	"haruki-database/database/schema/pjsk/groupalias"
	"haruki-database/database/schema/pjsk/pendingalias"
	"haruki-database/database/schema/pjsk/rejectedalias"
	"haruki-database/database/schema/pjsk/userbinding"
	"haruki-database/database/schema/pjsk/userdefaultbinding"
	"haruki-database/database/schema/pjsk/userpreference"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Alias is the client for interacting with the Alias builders.
	Alias *AliasClient
	// AliasAdmin is the client for interacting with the AliasAdmin builders.
	AliasAdmin *AliasAdminClient
	// GroupAlias is the client for interacting with the GroupAlias builders.
	GroupAlias *GroupAliasClient
	// PendingAlias is the client for interacting with the PendingAlias builders.
	PendingAlias *PendingAliasClient
	// RejectedAlias is the client for interacting with the RejectedAlias builders.
	RejectedAlias *RejectedAliasClient
	// UserBinding is the client for interacting with the UserBinding builders.
	UserBinding *UserBindingClient
	// UserDefaultBinding is the client for interacting with the UserDefaultBinding builders.
	UserDefaultBinding *UserDefaultBindingClient
	// UserPreference is the client for interacting with the UserPreference builders.
	UserPreference *UserPreferenceClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Alias = NewAliasClient(c.config)
	c.AliasAdmin = NewAliasAdminClient(c.config)
	c.GroupAlias = NewGroupAliasClient(c.config)
	c.PendingAlias = NewPendingAliasClient(c.config)
	c.RejectedAlias = NewRejectedAliasClient(c.config)
	c.UserBinding = NewUserBindingClient(c.config)
	c.UserDefaultBinding = NewUserDefaultBindingClient(c.config)
	c.UserPreference = NewUserPreferenceClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("pjsk: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("pjsk: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Alias:              NewAliasClient(cfg),
		AliasAdmin:         NewAliasAdminClient(cfg),
		GroupAlias:         NewGroupAliasClient(cfg),
		PendingAlias:       NewPendingAliasClient(cfg),
		RejectedAlias:      NewRejectedAliasClient(cfg),
		UserBinding:        NewUserBindingClient(cfg),
		UserDefaultBinding: NewUserDefaultBindingClient(cfg),
		UserPreference:     NewUserPreferenceClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Alias:              NewAliasClient(cfg),
		AliasAdmin:         NewAliasAdminClient(cfg),
		GroupAlias:         NewGroupAliasClient(cfg),
		PendingAlias:       NewPendingAliasClient(cfg),
		RejectedAlias:      NewRejectedAliasClient(cfg),
		UserBinding:        NewUserBindingClient(cfg),
		UserDefaultBinding: NewUserDefaultBindingClient(cfg),
		UserPreference:     NewUserPreferenceClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Alias.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Alias, c.AliasAdmin, c.GroupAlias, c.PendingAlias, c.RejectedAlias,
		c.UserBinding, c.UserDefaultBinding, c.UserPreference,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Alias, c.AliasAdmin, c.GroupAlias, c.PendingAlias, c.RejectedAlias,
		c.UserBinding, c.UserDefaultBinding, c.UserPreference,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AliasMutation:
		return c.Alias.mutate(ctx, m)
	case *AliasAdminMutation:
		return c.AliasAdmin.mutate(ctx, m)
	case *GroupAliasMutation:
		return c.GroupAlias.mutate(ctx, m)
	case *PendingAliasMutation:
		return c.PendingAlias.mutate(ctx, m)
	case *RejectedAliasMutation:
		return c.RejectedAlias.mutate(ctx, m)
	case *UserBindingMutation:
		return c.UserBinding.mutate(ctx, m)
	case *UserDefaultBindingMutation:
		return c.UserDefaultBinding.mutate(ctx, m)
	case *UserPreferenceMutation:
		return c.UserPreference.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("pjsk: unknown mutation type %T", m)
	}
}

// AliasClient is a client for the Alias schema.
type AliasClient struct {
	config
}

// NewAliasClient returns a client for the Alias from the given config.
func NewAliasClient(c config) *AliasClient {
	return &AliasClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alias.Hooks(f(g(h())))`.
func (c *AliasClient) Use(hooks ...Hook) {
	c.hooks.Alias = append(c.hooks.Alias, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `alias.Intercept(f(g(h())))`.
func (c *AliasClient) Intercept(interceptors ...Interceptor) {
	c.inters.Alias = append(c.inters.Alias, interceptors...)
}

// Create returns a builder for creating a Alias entity.
func (c *AliasClient) Create() *AliasCreate {
	mutation := newAliasMutation(c.config, OpCreate)
	return &AliasCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Alias entities.
func (c *AliasClient) CreateBulk(builders ...*AliasCreate) *AliasCreateBulk {
	return &AliasCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AliasClient) MapCreateBulk(slice any, setFunc func(*AliasCreate, int)) *AliasCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AliasCreateBulk{err: fmt.Errorf("calling to AliasClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AliasCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AliasCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Alias.
func (c *AliasClient) Update() *AliasUpdate {
	mutation := newAliasMutation(c.config, OpUpdate)
	return &AliasUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AliasClient) UpdateOne(_m *Alias) *AliasUpdateOne {
	mutation := newAliasMutation(c.config, OpUpdateOne, withAlias(_m))
	return &AliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AliasClient) UpdateOneID(id int64) *AliasUpdateOne {
	mutation := newAliasMutation(c.config, OpUpdateOne, withAliasID(id))
	return &AliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Alias.
func (c *AliasClient) Delete() *AliasDelete {
	mutation := newAliasMutation(c.config, OpDelete)
	return &AliasDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AliasClient) DeleteOne(_m *Alias) *AliasDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AliasClient) DeleteOneID(id int64) *AliasDeleteOne {
	builder := c.Delete().Where(alias.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AliasDeleteOne{builder}
}

// Query returns a query builder for Alias.
func (c *AliasClient) Query() *AliasQuery {
	return &AliasQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlias},
		inters: c.Interceptors(),
	}
}

// Get returns a Alias entity by its id.
func (c *AliasClient) Get(ctx context.Context, id int64) (*Alias, error) {
	return c.Query().Where(alias.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AliasClient) GetX(ctx context.Context, id int64) *Alias {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AliasClient) Hooks() []Hook {
	return c.hooks.Alias
}

// Interceptors returns the client interceptors.
func (c *AliasClient) Interceptors() []Interceptor {
	return c.inters.Alias
}

func (c *AliasClient) mutate(ctx context.Context, m *AliasMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AliasCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AliasUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AliasDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("pjsk: unknown Alias mutation op: %q", m.Op())
	}
}

// AliasAdminClient is a client for the AliasAdmin schema.
type AliasAdminClient struct {
	config
}

// NewAliasAdminClient returns a client for the AliasAdmin from the given config.
func NewAliasAdminClient(c config) *AliasAdminClient {
	return &AliasAdminClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `aliasadmin.Hooks(f(g(h())))`.
func (c *AliasAdminClient) Use(hooks ...Hook) {
	c.hooks.AliasAdmin = append(c.hooks.AliasAdmin, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `aliasadmin.Intercept(f(g(h())))`.
func (c *AliasAdminClient) Intercept(interceptors ...Interceptor) {
	c.inters.AliasAdmin = append(c.inters.AliasAdmin, interceptors...)
}

// Create returns a builder for creating a AliasAdmin entity.
func (c *AliasAdminClient) Create() *AliasAdminCreate {
	mutation := newAliasAdminMutation(c.config, OpCreate)
	return &AliasAdminCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AliasAdmin entities.
func (c *AliasAdminClient) CreateBulk(builders ...*AliasAdminCreate) *AliasAdminCreateBulk {
	return &AliasAdminCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AliasAdminClient) MapCreateBulk(slice any, setFunc func(*AliasAdminCreate, int)) *AliasAdminCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AliasAdminCreateBulk{err: fmt.Errorf("calling to AliasAdminClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AliasAdminCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AliasAdminCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AliasAdmin.
func (c *AliasAdminClient) Update() *AliasAdminUpdate {
	mutation := newAliasAdminMutation(c.config, OpUpdate)
	return &AliasAdminUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AliasAdminClient) UpdateOne(_m *AliasAdmin) *AliasAdminUpdateOne {
	mutation := newAliasAdminMutation(c.config, OpUpdateOne, withAliasAdmin(_m))
	return &AliasAdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AliasAdminClient) UpdateOneID(id int) *AliasAdminUpdateOne {
	mutation := newAliasAdminMutation(c.config, OpUpdateOne, withAliasAdminID(id))
	return &AliasAdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AliasAdmin.
func (c *AliasAdminClient) Delete() *AliasAdminDelete {
	mutation := newAliasAdminMutation(c.config, OpDelete)
	return &AliasAdminDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AliasAdminClient) DeleteOne(_m *AliasAdmin) *AliasAdminDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AliasAdminClient) DeleteOneID(id int) *AliasAdminDeleteOne {
	builder := c.Delete().Where(aliasadmin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AliasAdminDeleteOne{builder}
}

// Query returns a query builder for AliasAdmin.
func (c *AliasAdminClient) Query() *AliasAdminQuery {
	return &AliasAdminQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAliasAdmin},
		inters: c.Interceptors(),
	}
}

// Get returns a AliasAdmin entity by its id.
func (c *AliasAdminClient) Get(ctx context.Context, id int) (*AliasAdmin, error) {
	return c.Query().Where(aliasadmin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AliasAdminClient) GetX(ctx context.Context, id int) *AliasAdmin {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AliasAdminClient) Hooks() []Hook {
	return c.hooks.AliasAdmin
}

// Interceptors returns the client interceptors.
func (c *AliasAdminClient) Interceptors() []Interceptor {
	return c.inters.AliasAdmin
}

func (c *AliasAdminClient) mutate(ctx context.Context, m *AliasAdminMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AliasAdminCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AliasAdminUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AliasAdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AliasAdminDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("pjsk: unknown AliasAdmin mutation op: %q", m.Op())
	}
}

// GroupAliasClient is a client for the GroupAlias schema.
type GroupAliasClient struct {
	config
}

// NewGroupAliasClient returns a client for the GroupAlias from the given config.
func NewGroupAliasClient(c config) *GroupAliasClient {
	return &GroupAliasClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupalias.Hooks(f(g(h())))`.
func (c *GroupAliasClient) Use(hooks ...Hook) {
	c.hooks.GroupAlias = append(c.hooks.GroupAlias, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupalias.Intercept(f(g(h())))`.
func (c *GroupAliasClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupAlias = append(c.inters.GroupAlias, interceptors...)
}

// Create returns a builder for creating a GroupAlias entity.
func (c *GroupAliasClient) Create() *GroupAliasCreate {
	mutation := newGroupAliasMutation(c.config, OpCreate)
	return &GroupAliasCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupAlias entities.
func (c *GroupAliasClient) CreateBulk(builders ...*GroupAliasCreate) *GroupAliasCreateBulk {
	return &GroupAliasCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupAliasClient) MapCreateBulk(slice any, setFunc func(*GroupAliasCreate, int)) *GroupAliasCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupAliasCreateBulk{err: fmt.Errorf("calling to GroupAliasClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupAliasCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupAliasCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupAlias.
func (c *GroupAliasClient) Update() *GroupAliasUpdate {
	mutation := newGroupAliasMutation(c.config, OpUpdate)
	return &GroupAliasUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupAliasClient) UpdateOne(_m *GroupAlias) *GroupAliasUpdateOne {
	mutation := newGroupAliasMutation(c.config, OpUpdateOne, withGroupAlias(_m))
	return &GroupAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupAliasClient) UpdateOneID(id int) *GroupAliasUpdateOne {
	mutation := newGroupAliasMutation(c.config, OpUpdateOne, withGroupAliasID(id))
	return &GroupAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupAlias.
func (c *GroupAliasClient) Delete() *GroupAliasDelete {
	mutation := newGroupAliasMutation(c.config, OpDelete)
	return &GroupAliasDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupAliasClient) DeleteOne(_m *GroupAlias) *GroupAliasDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupAliasClient) DeleteOneID(id int) *GroupAliasDeleteOne {
	builder := c.Delete().Where(groupalias.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupAliasDeleteOne{builder}
}

// Query returns a query builder for GroupAlias.
func (c *GroupAliasClient) Query() *GroupAliasQuery {
	return &GroupAliasQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupAlias},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupAlias entity by its id.
func (c *GroupAliasClient) Get(ctx context.Context, id int) (*GroupAlias, error) {
	return c.Query().Where(groupalias.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupAliasClient) GetX(ctx context.Context, id int) *GroupAlias {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GroupAliasClient) Hooks() []Hook {
	return c.hooks.GroupAlias
}

// Interceptors returns the client interceptors.
func (c *GroupAliasClient) Interceptors() []Interceptor {
	return c.inters.GroupAlias
}

func (c *GroupAliasClient) mutate(ctx context.Context, m *GroupAliasMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupAliasCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupAliasUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupAliasDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("pjsk: unknown GroupAlias mutation op: %q", m.Op())
	}
}

// PendingAliasClient is a client for the PendingAlias schema.
type PendingAliasClient struct {
	config
}

// NewPendingAliasClient returns a client for the PendingAlias from the given config.
func NewPendingAliasClient(c config) *PendingAliasClient {
	return &PendingAliasClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pendingalias.Hooks(f(g(h())))`.
func (c *PendingAliasClient) Use(hooks ...Hook) {
	c.hooks.PendingAlias = append(c.hooks.PendingAlias, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pendingalias.Intercept(f(g(h())))`.
func (c *PendingAliasClient) Intercept(interceptors ...Interceptor) {
	c.inters.PendingAlias = append(c.inters.PendingAlias, interceptors...)
}

// Create returns a builder for creating a PendingAlias entity.
func (c *PendingAliasClient) Create() *PendingAliasCreate {
	mutation := newPendingAliasMutation(c.config, OpCreate)
	return &PendingAliasCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PendingAlias entities.
func (c *PendingAliasClient) CreateBulk(builders ...*PendingAliasCreate) *PendingAliasCreateBulk {
	return &PendingAliasCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PendingAliasClient) MapCreateBulk(slice any, setFunc func(*PendingAliasCreate, int)) *PendingAliasCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PendingAliasCreateBulk{err: fmt.Errorf("calling to PendingAliasClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PendingAliasCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PendingAliasCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PendingAlias.
func (c *PendingAliasClient) Update() *PendingAliasUpdate {
	mutation := newPendingAliasMutation(c.config, OpUpdate)
	return &PendingAliasUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PendingAliasClient) UpdateOne(_m *PendingAlias) *PendingAliasUpdateOne {
	mutation := newPendingAliasMutation(c.config, OpUpdateOne, withPendingAlias(_m))
	return &PendingAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PendingAliasClient) UpdateOneID(id int64) *PendingAliasUpdateOne {
	mutation := newPendingAliasMutation(c.config, OpUpdateOne, withPendingAliasID(id))
	return &PendingAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PendingAlias.
func (c *PendingAliasClient) Delete() *PendingAliasDelete {
	mutation := newPendingAliasMutation(c.config, OpDelete)
	return &PendingAliasDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PendingAliasClient) DeleteOne(_m *PendingAlias) *PendingAliasDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PendingAliasClient) DeleteOneID(id int64) *PendingAliasDeleteOne {
	builder := c.Delete().Where(pendingalias.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PendingAliasDeleteOne{builder}
}

// Query returns a query builder for PendingAlias.
func (c *PendingAliasClient) Query() *PendingAliasQuery {
	return &PendingAliasQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePendingAlias},
		inters: c.Interceptors(),
	}
}

// Get returns a PendingAlias entity by its id.
func (c *PendingAliasClient) Get(ctx context.Context, id int64) (*PendingAlias, error) {
	return c.Query().Where(pendingalias.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PendingAliasClient) GetX(ctx context.Context, id int64) *PendingAlias {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PendingAliasClient) Hooks() []Hook {
	return c.hooks.PendingAlias
}

// Interceptors returns the client interceptors.
func (c *PendingAliasClient) Interceptors() []Interceptor {
	return c.inters.PendingAlias
}

func (c *PendingAliasClient) mutate(ctx context.Context, m *PendingAliasMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PendingAliasCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PendingAliasUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PendingAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PendingAliasDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("pjsk: unknown PendingAlias mutation op: %q", m.Op())
	}
}

// RejectedAliasClient is a client for the RejectedAlias schema.
type RejectedAliasClient struct {
	config
}

// NewRejectedAliasClient returns a client for the RejectedAlias from the given config.
func NewRejectedAliasClient(c config) *RejectedAliasClient {
	return &RejectedAliasClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rejectedalias.Hooks(f(g(h())))`.
func (c *RejectedAliasClient) Use(hooks ...Hook) {
	c.hooks.RejectedAlias = append(c.hooks.RejectedAlias, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rejectedalias.Intercept(f(g(h())))`.
func (c *RejectedAliasClient) Intercept(interceptors ...Interceptor) {
	c.inters.RejectedAlias = append(c.inters.RejectedAlias, interceptors...)
}

// Create returns a builder for creating a RejectedAlias entity.
func (c *RejectedAliasClient) Create() *RejectedAliasCreate {
	mutation := newRejectedAliasMutation(c.config, OpCreate)
	return &RejectedAliasCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RejectedAlias entities.
func (c *RejectedAliasClient) CreateBulk(builders ...*RejectedAliasCreate) *RejectedAliasCreateBulk {
	return &RejectedAliasCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RejectedAliasClient) MapCreateBulk(slice any, setFunc func(*RejectedAliasCreate, int)) *RejectedAliasCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RejectedAliasCreateBulk{err: fmt.Errorf("calling to RejectedAliasClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RejectedAliasCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RejectedAliasCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RejectedAlias.
func (c *RejectedAliasClient) Update() *RejectedAliasUpdate {
	mutation := newRejectedAliasMutation(c.config, OpUpdate)
	return &RejectedAliasUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RejectedAliasClient) UpdateOne(_m *RejectedAlias) *RejectedAliasUpdateOne {
	mutation := newRejectedAliasMutation(c.config, OpUpdateOne, withRejectedAlias(_m))
	return &RejectedAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RejectedAliasClient) UpdateOneID(id int64) *RejectedAliasUpdateOne {
	mutation := newRejectedAliasMutation(c.config, OpUpdateOne, withRejectedAliasID(id))
	return &RejectedAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RejectedAlias.
func (c *RejectedAliasClient) Delete() *RejectedAliasDelete {
	mutation := newRejectedAliasMutation(c.config, OpDelete)
	return &RejectedAliasDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RejectedAliasClient) DeleteOne(_m *RejectedAlias) *RejectedAliasDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RejectedAliasClient) DeleteOneID(id int64) *RejectedAliasDeleteOne {
	builder := c.Delete().Where(rejectedalias.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RejectedAliasDeleteOne{builder}
}

// Query returns a query builder for RejectedAlias.
func (c *RejectedAliasClient) Query() *RejectedAliasQuery {
	return &RejectedAliasQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRejectedAlias},
		inters: c.Interceptors(),
	}
}

// Get returns a RejectedAlias entity by its id.
func (c *RejectedAliasClient) Get(ctx context.Context, id int64) (*RejectedAlias, error) {
	return c.Query().Where(rejectedalias.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RejectedAliasClient) GetX(ctx context.Context, id int64) *RejectedAlias {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RejectedAliasClient) Hooks() []Hook {
	return c.hooks.RejectedAlias
}

// Interceptors returns the client interceptors.
func (c *RejectedAliasClient) Interceptors() []Interceptor {
	return c.inters.RejectedAlias
}

func (c *RejectedAliasClient) mutate(ctx context.Context, m *RejectedAliasMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RejectedAliasCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RejectedAliasUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RejectedAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RejectedAliasDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("pjsk: unknown RejectedAlias mutation op: %q", m.Op())
	}
}

// UserBindingClient is a client for the UserBinding schema.
type UserBindingClient struct {
	config
}

// NewUserBindingClient returns a client for the UserBinding from the given config.
func NewUserBindingClient(c config) *UserBindingClient {
	return &UserBindingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userbinding.Hooks(f(g(h())))`.
func (c *UserBindingClient) Use(hooks ...Hook) {
	c.hooks.UserBinding = append(c.hooks.UserBinding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userbinding.Intercept(f(g(h())))`.
func (c *UserBindingClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserBinding = append(c.inters.UserBinding, interceptors...)
}

// Create returns a builder for creating a UserBinding entity.
func (c *UserBindingClient) Create() *UserBindingCreate {
	mutation := newUserBindingMutation(c.config, OpCreate)
	return &UserBindingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserBinding entities.
func (c *UserBindingClient) CreateBulk(builders ...*UserBindingCreate) *UserBindingCreateBulk {
	return &UserBindingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserBindingClient) MapCreateBulk(slice any, setFunc func(*UserBindingCreate, int)) *UserBindingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserBindingCreateBulk{err: fmt.Errorf("calling to UserBindingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserBindingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserBindingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserBinding.
func (c *UserBindingClient) Update() *UserBindingUpdate {
	mutation := newUserBindingMutation(c.config, OpUpdate)
	return &UserBindingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserBindingClient) UpdateOne(_m *UserBinding) *UserBindingUpdateOne {
	mutation := newUserBindingMutation(c.config, OpUpdateOne, withUserBinding(_m))
	return &UserBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserBindingClient) UpdateOneID(id int) *UserBindingUpdateOne {
	mutation := newUserBindingMutation(c.config, OpUpdateOne, withUserBindingID(id))
	return &UserBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserBinding.
func (c *UserBindingClient) Delete() *UserBindingDelete {
	mutation := newUserBindingMutation(c.config, OpDelete)
	return &UserBindingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserBindingClient) DeleteOne(_m *UserBinding) *UserBindingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserBindingClient) DeleteOneID(id int) *UserBindingDeleteOne {
	builder := c.Delete().Where(userbinding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserBindingDeleteOne{builder}
}

// Query returns a query builder for UserBinding.
func (c *UserBindingClient) Query() *UserBindingQuery {
	return &UserBindingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserBinding},
		inters: c.Interceptors(),
	}
}

// Get returns a UserBinding entity by its id.
func (c *UserBindingClient) Get(ctx context.Context, id int) (*UserBinding, error) {
	return c.Query().Where(userbinding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserBindingClient) GetX(ctx context.Context, id int) *UserBinding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDefaultRefs queries the default_refs edge of a UserBinding.
func (c *UserBindingClient) QueryDefaultRefs(_m *UserBinding) *UserDefaultBindingQuery {
	query := (&UserDefaultBindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userbinding.Table, userbinding.FieldID, id),
			sqlgraph.To(userdefaultbinding.Table, userdefaultbinding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, userbinding.DefaultRefsTable, userbinding.DefaultRefsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserBindingClient) Hooks() []Hook {
	return c.hooks.UserBinding
}

// Interceptors returns the client interceptors.
func (c *UserBindingClient) Interceptors() []Interceptor {
	return c.inters.UserBinding
}

func (c *UserBindingClient) mutate(ctx context.Context, m *UserBindingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserBindingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserBindingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserBindingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("pjsk: unknown UserBinding mutation op: %q", m.Op())
	}
}

// UserDefaultBindingClient is a client for the UserDefaultBinding schema.
type UserDefaultBindingClient struct {
	config
}

// NewUserDefaultBindingClient returns a client for the UserDefaultBinding from the given config.
func NewUserDefaultBindingClient(c config) *UserDefaultBindingClient {
	return &UserDefaultBindingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userdefaultbinding.Hooks(f(g(h())))`.
func (c *UserDefaultBindingClient) Use(hooks ...Hook) {
	c.hooks.UserDefaultBinding = append(c.hooks.UserDefaultBinding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userdefaultbinding.Intercept(f(g(h())))`.
func (c *UserDefaultBindingClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserDefaultBinding = append(c.inters.UserDefaultBinding, interceptors...)
}

// Create returns a builder for creating a UserDefaultBinding entity.
func (c *UserDefaultBindingClient) Create() *UserDefaultBindingCreate {
	mutation := newUserDefaultBindingMutation(c.config, OpCreate)
	return &UserDefaultBindingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserDefaultBinding entities.
func (c *UserDefaultBindingClient) CreateBulk(builders ...*UserDefaultBindingCreate) *UserDefaultBindingCreateBulk {
	return &UserDefaultBindingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserDefaultBindingClient) MapCreateBulk(slice any, setFunc func(*UserDefaultBindingCreate, int)) *UserDefaultBindingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserDefaultBindingCreateBulk{err: fmt.Errorf("calling to UserDefaultBindingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserDefaultBindingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserDefaultBindingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserDefaultBinding.
func (c *UserDefaultBindingClient) Update() *UserDefaultBindingUpdate {
	mutation := newUserDefaultBindingMutation(c.config, OpUpdate)
	return &UserDefaultBindingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserDefaultBindingClient) UpdateOne(_m *UserDefaultBinding) *UserDefaultBindingUpdateOne {
	mutation := newUserDefaultBindingMutation(c.config, OpUpdateOne, withUserDefaultBinding(_m))
	return &UserDefaultBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserDefaultBindingClient) UpdateOneID(id int) *UserDefaultBindingUpdateOne {
	mutation := newUserDefaultBindingMutation(c.config, OpUpdateOne, withUserDefaultBindingID(id))
	return &UserDefaultBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserDefaultBinding.
func (c *UserDefaultBindingClient) Delete() *UserDefaultBindingDelete {
	mutation := newUserDefaultBindingMutation(c.config, OpDelete)
	return &UserDefaultBindingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserDefaultBindingClient) DeleteOne(_m *UserDefaultBinding) *UserDefaultBindingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserDefaultBindingClient) DeleteOneID(id int) *UserDefaultBindingDeleteOne {
	builder := c.Delete().Where(userdefaultbinding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDefaultBindingDeleteOne{builder}
}

// Query returns a query builder for UserDefaultBinding.
func (c *UserDefaultBindingClient) Query() *UserDefaultBindingQuery {
	return &UserDefaultBindingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserDefaultBinding},
		inters: c.Interceptors(),
	}
}

// Get returns a UserDefaultBinding entity by its id.
func (c *UserDefaultBindingClient) Get(ctx context.Context, id int) (*UserDefaultBinding, error) {
	return c.Query().Where(userdefaultbinding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserDefaultBindingClient) GetX(ctx context.Context, id int) *UserDefaultBinding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBinding queries the binding edge of a UserDefaultBinding.
func (c *UserDefaultBindingClient) QueryBinding(_m *UserDefaultBinding) *UserBindingQuery {
	query := (&UserBindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userdefaultbinding.Table, userdefaultbinding.FieldID, id),
			sqlgraph.To(userbinding.Table, userbinding.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userdefaultbinding.BindingTable, userdefaultbinding.BindingColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserDefaultBindingClient) Hooks() []Hook {
	return c.hooks.UserDefaultBinding
}

// Interceptors returns the client interceptors.
func (c *UserDefaultBindingClient) Interceptors() []Interceptor {
	return c.inters.UserDefaultBinding
}

func (c *UserDefaultBindingClient) mutate(ctx context.Context, m *UserDefaultBindingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserDefaultBindingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserDefaultBindingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserDefaultBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDefaultBindingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("pjsk: unknown UserDefaultBinding mutation op: %q", m.Op())
	}
}

// UserPreferenceClient is a client for the UserPreference schema.
type UserPreferenceClient struct {
	config
}

// NewUserPreferenceClient returns a client for the UserPreference from the given config.
func NewUserPreferenceClient(c config) *UserPreferenceClient {
	return &UserPreferenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userpreference.Hooks(f(g(h())))`.
func (c *UserPreferenceClient) Use(hooks ...Hook) {
	c.hooks.UserPreference = append(c.hooks.UserPreference, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userpreference.Intercept(f(g(h())))`.
func (c *UserPreferenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserPreference = append(c.inters.UserPreference, interceptors...)
}

// Create returns a builder for creating a UserPreference entity.
func (c *UserPreferenceClient) Create() *UserPreferenceCreate {
	mutation := newUserPreferenceMutation(c.config, OpCreate)
	return &UserPreferenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserPreference entities.
func (c *UserPreferenceClient) CreateBulk(builders ...*UserPreferenceCreate) *UserPreferenceCreateBulk {
	return &UserPreferenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserPreferenceClient) MapCreateBulk(slice any, setFunc func(*UserPreferenceCreate, int)) *UserPreferenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserPreferenceCreateBulk{err: fmt.Errorf("calling to UserPreferenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserPreferenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserPreferenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserPreference.
func (c *UserPreferenceClient) Update() *UserPreferenceUpdate {
	mutation := newUserPreferenceMutation(c.config, OpUpdate)
	return &UserPreferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserPreferenceClient) UpdateOne(_m *UserPreference) *UserPreferenceUpdateOne {
	mutation := newUserPreferenceMutation(c.config, OpUpdateOne, withUserPreference(_m))
	return &UserPreferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserPreferenceClient) UpdateOneID(id int) *UserPreferenceUpdateOne {
	mutation := newUserPreferenceMutation(c.config, OpUpdateOne, withUserPreferenceID(id))
	return &UserPreferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserPreference.
func (c *UserPreferenceClient) Delete() *UserPreferenceDelete {
	mutation := newUserPreferenceMutation(c.config, OpDelete)
	return &UserPreferenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserPreferenceClient) DeleteOne(_m *UserPreference) *UserPreferenceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserPreferenceClient) DeleteOneID(id int) *UserPreferenceDeleteOne {
	builder := c.Delete().Where(userpreference.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserPreferenceDeleteOne{builder}
}

// Query returns a query builder for UserPreference.
func (c *UserPreferenceClient) Query() *UserPreferenceQuery {
	return &UserPreferenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserPreference},
		inters: c.Interceptors(),
	}
}

// Get returns a UserPreference entity by its id.
func (c *UserPreferenceClient) Get(ctx context.Context, id int) (*UserPreference, error) {
	return c.Query().Where(userpreference.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserPreferenceClient) GetX(ctx context.Context, id int) *UserPreference {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserPreferenceClient) Hooks() []Hook {
	return c.hooks.UserPreference
}

// Interceptors returns the client interceptors.
func (c *UserPreferenceClient) Interceptors() []Interceptor {
	return c.inters.UserPreference
}

func (c *UserPreferenceClient) mutate(ctx context.Context, m *UserPreferenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserPreferenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserPreferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserPreferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserPreferenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("pjsk: unknown UserPreference mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Alias, AliasAdmin, GroupAlias, PendingAlias, RejectedAlias, UserBinding,
		UserDefaultBinding, UserPreference []ent.Hook
	}
	inters struct {
		Alias, AliasAdmin, GroupAlias, PendingAlias, RejectedAlias, UserBinding,
		UserDefaultBinding, UserPreference []ent.Interceptor
	}
)
