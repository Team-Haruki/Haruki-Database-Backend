// Code generated by ent, DO NOT EDIT.

package pjsk

import (
	"context"
	"errors"
	"fmt"
	"haruki-database/database/schema/pjsk/alias"
	"haruki-database/database/schema/pjsk/aliasadmin"
	"haruki-database/database/schema/pjsk/groupalias"
	"haruki-database/database/schema/pjsk/pendingalias"
	"haruki-database/database/schema/pjsk/predicate"
	"haruki-database/database/schema/pjsk/rejectedalias"
	"haruki-database/database/schema/pjsk/userbinding"
	"haruki-database/database/schema/pjsk/userdefaultbinding"
	"haruki-database/database/schema/pjsk/userpreference"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlias              = "Alias"
	TypeAliasAdmin         = "AliasAdmin"
	TypeGroupAlias         = "GroupAlias"
	TypePendingAlias       = "PendingAlias"
	TypeRejectedAlias      = "RejectedAlias"
	TypeUserBinding        = "UserBinding"
	TypeUserDefaultBinding = "UserDefaultBinding"
	TypeUserPreference     = "UserPreference"
)

// AliasMutation represents an operation that mutates the Alias nodes in the graph.
type AliasMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	alias_type       *string
	alias_type_id    *int
	addalias_type_id *int
	alias            *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Alias, error)
	predicates       []predicate.Alias
}

var _ ent.Mutation = (*AliasMutation)(nil)

// aliasOption allows management of the mutation configuration using functional options.
type aliasOption func(*AliasMutation)

// newAliasMutation creates new mutation for the Alias entity.
func newAliasMutation(c config, op Op, opts ...aliasOption) *AliasMutation {
	m := &AliasMutation{
		config:        c,
		op:            op,
		typ:           TypeAlias,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAliasID sets the ID field of the mutation.
func withAliasID(id int64) aliasOption {
	return func(m *AliasMutation) {
		var (
			err   error
			once  sync.Once
			value *Alias
		)
		m.oldValue = func(ctx context.Context) (*Alias, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Alias.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlias sets the old Alias of the mutation.
func withAlias(node *Alias) aliasOption {
	return func(m *AliasMutation) {
		m.oldValue = func(context.Context) (*Alias, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AliasMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AliasMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("pjsk: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Alias entities.
func (m *AliasMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AliasMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AliasMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Alias.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAliasType sets the "alias_type" field.
func (m *AliasMutation) SetAliasType(s string) {
	m.alias_type = &s
}

// AliasType returns the value of the "alias_type" field in the mutation.
func (m *AliasMutation) AliasType() (r string, exists bool) {
	v := m.alias_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAliasType returns the old "alias_type" field's value of the Alias entity.
// If the Alias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AliasMutation) OldAliasType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliasType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliasType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliasType: %w", err)
	}
	return oldValue.AliasType, nil
}

// ResetAliasType resets all changes to the "alias_type" field.
func (m *AliasMutation) ResetAliasType() {
	m.alias_type = nil
}

// SetAliasTypeID sets the "alias_type_id" field.
func (m *AliasMutation) SetAliasTypeID(i int) {
	m.alias_type_id = &i
	m.addalias_type_id = nil
}

// AliasTypeID returns the value of the "alias_type_id" field in the mutation.
func (m *AliasMutation) AliasTypeID() (r int, exists bool) {
	v := m.alias_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAliasTypeID returns the old "alias_type_id" field's value of the Alias entity.
// If the Alias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AliasMutation) OldAliasTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliasTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliasTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliasTypeID: %w", err)
	}
	return oldValue.AliasTypeID, nil
}

// AddAliasTypeID adds i to the "alias_type_id" field.
func (m *AliasMutation) AddAliasTypeID(i int) {
	if m.addalias_type_id != nil {
		*m.addalias_type_id += i
	} else {
		m.addalias_type_id = &i
	}
}

// AddedAliasTypeID returns the value that was added to the "alias_type_id" field in this mutation.
func (m *AliasMutation) AddedAliasTypeID() (r int, exists bool) {
	v := m.addalias_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAliasTypeID resets all changes to the "alias_type_id" field.
func (m *AliasMutation) ResetAliasTypeID() {
	m.alias_type_id = nil
	m.addalias_type_id = nil
}

// SetAlias sets the "alias" field.
func (m *AliasMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *AliasMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the Alias entity.
// If the Alias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AliasMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *AliasMutation) ResetAlias() {
	m.alias = nil
}

// Where appends a list predicates to the AliasMutation builder.
func (m *AliasMutation) Where(ps ...predicate.Alias) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AliasMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AliasMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Alias, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AliasMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AliasMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Alias).
func (m *AliasMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AliasMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.alias_type != nil {
		fields = append(fields, alias.FieldAliasType)
	}
	if m.alias_type_id != nil {
		fields = append(fields, alias.FieldAliasTypeID)
	}
	if m.alias != nil {
		fields = append(fields, alias.FieldAlias)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AliasMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alias.FieldAliasType:
		return m.AliasType()
	case alias.FieldAliasTypeID:
		return m.AliasTypeID()
	case alias.FieldAlias:
		return m.Alias()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AliasMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alias.FieldAliasType:
		return m.OldAliasType(ctx)
	case alias.FieldAliasTypeID:
		return m.OldAliasTypeID(ctx)
	case alias.FieldAlias:
		return m.OldAlias(ctx)
	}
	return nil, fmt.Errorf("unknown Alias field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AliasMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alias.FieldAliasType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliasType(v)
		return nil
	case alias.FieldAliasTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliasTypeID(v)
		return nil
	case alias.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	}
	return fmt.Errorf("unknown Alias field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AliasMutation) AddedFields() []string {
	var fields []string
	if m.addalias_type_id != nil {
		fields = append(fields, alias.FieldAliasTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AliasMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alias.FieldAliasTypeID:
		return m.AddedAliasTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AliasMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alias.FieldAliasTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAliasTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown Alias numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AliasMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AliasMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AliasMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Alias nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AliasMutation) ResetField(name string) error {
	switch name {
	case alias.FieldAliasType:
		m.ResetAliasType()
		return nil
	case alias.FieldAliasTypeID:
		m.ResetAliasTypeID()
		return nil
	case alias.FieldAlias:
		m.ResetAlias()
		return nil
	}
	return fmt.Errorf("unknown Alias field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AliasMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AliasMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AliasMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AliasMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AliasMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AliasMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AliasMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Alias unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AliasMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Alias edge %s", name)
}

// AliasAdminMutation represents an operation that mutates the AliasAdmin nodes in the graph.
type AliasAdminMutation struct {
	config
	op            Op
	typ           string
	id            *int
	platform      *string
	im_id         *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AliasAdmin, error)
	predicates    []predicate.AliasAdmin
}

var _ ent.Mutation = (*AliasAdminMutation)(nil)

// aliasadminOption allows management of the mutation configuration using functional options.
type aliasadminOption func(*AliasAdminMutation)

// newAliasAdminMutation creates new mutation for the AliasAdmin entity.
func newAliasAdminMutation(c config, op Op, opts ...aliasadminOption) *AliasAdminMutation {
	m := &AliasAdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAliasAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAliasAdminID sets the ID field of the mutation.
func withAliasAdminID(id int) aliasadminOption {
	return func(m *AliasAdminMutation) {
		var (
			err   error
			once  sync.Once
			value *AliasAdmin
		)
		m.oldValue = func(ctx context.Context) (*AliasAdmin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AliasAdmin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAliasAdmin sets the old AliasAdmin of the mutation.
func withAliasAdmin(node *AliasAdmin) aliasadminOption {
	return func(m *AliasAdminMutation) {
		m.oldValue = func(context.Context) (*AliasAdmin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AliasAdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AliasAdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("pjsk: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AliasAdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AliasAdminMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AliasAdmin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlatform sets the "platform" field.
func (m *AliasAdminMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AliasAdminMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the AliasAdmin entity.
// If the AliasAdmin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AliasAdminMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AliasAdminMutation) ResetPlatform() {
	m.platform = nil
}

// SetImID sets the "im_id" field.
func (m *AliasAdminMutation) SetImID(s string) {
	m.im_id = &s
}

// ImID returns the value of the "im_id" field in the mutation.
func (m *AliasAdminMutation) ImID() (r string, exists bool) {
	v := m.im_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImID returns the old "im_id" field's value of the AliasAdmin entity.
// If the AliasAdmin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AliasAdminMutation) OldImID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImID: %w", err)
	}
	return oldValue.ImID, nil
}

// ResetImID resets all changes to the "im_id" field.
func (m *AliasAdminMutation) ResetImID() {
	m.im_id = nil
}

// SetName sets the "name" field.
func (m *AliasAdminMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AliasAdminMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AliasAdmin entity.
// If the AliasAdmin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AliasAdminMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AliasAdminMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the AliasAdminMutation builder.
func (m *AliasAdminMutation) Where(ps ...predicate.AliasAdmin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AliasAdminMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AliasAdminMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AliasAdmin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AliasAdminMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AliasAdminMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AliasAdmin).
func (m *AliasAdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AliasAdminMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.platform != nil {
		fields = append(fields, aliasadmin.FieldPlatform)
	}
	if m.im_id != nil {
		fields = append(fields, aliasadmin.FieldImID)
	}
	if m.name != nil {
		fields = append(fields, aliasadmin.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AliasAdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case aliasadmin.FieldPlatform:
		return m.Platform()
	case aliasadmin.FieldImID:
		return m.ImID()
	case aliasadmin.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AliasAdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case aliasadmin.FieldPlatform:
		return m.OldPlatform(ctx)
	case aliasadmin.FieldImID:
		return m.OldImID(ctx)
	case aliasadmin.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown AliasAdmin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AliasAdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case aliasadmin.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case aliasadmin.FieldImID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImID(v)
		return nil
	case aliasadmin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown AliasAdmin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AliasAdminMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AliasAdminMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AliasAdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AliasAdmin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AliasAdminMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AliasAdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AliasAdminMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AliasAdmin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AliasAdminMutation) ResetField(name string) error {
	switch name {
	case aliasadmin.FieldPlatform:
		m.ResetPlatform()
		return nil
	case aliasadmin.FieldImID:
		m.ResetImID()
		return nil
	case aliasadmin.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown AliasAdmin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AliasAdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AliasAdminMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AliasAdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AliasAdminMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AliasAdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AliasAdminMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AliasAdminMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AliasAdmin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AliasAdminMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AliasAdmin edge %s", name)
}

// GroupAliasMutation represents an operation that mutates the GroupAlias nodes in the graph.
type GroupAliasMutation struct {
	config
	op               Op
	typ              string
	id               *int
	platform         *string
	group_id         *string
	alias_type       *string
	alias_type_id    *int
	addalias_type_id *int
	alias            *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*GroupAlias, error)
	predicates       []predicate.GroupAlias
}

var _ ent.Mutation = (*GroupAliasMutation)(nil)

// groupaliasOption allows management of the mutation configuration using functional options.
type groupaliasOption func(*GroupAliasMutation)

// newGroupAliasMutation creates new mutation for the GroupAlias entity.
func newGroupAliasMutation(c config, op Op, opts ...groupaliasOption) *GroupAliasMutation {
	m := &GroupAliasMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupAlias,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupAliasID sets the ID field of the mutation.
func withGroupAliasID(id int) groupaliasOption {
	return func(m *GroupAliasMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupAlias
		)
		m.oldValue = func(ctx context.Context) (*GroupAlias, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupAlias.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupAlias sets the old GroupAlias of the mutation.
func withGroupAlias(node *GroupAlias) groupaliasOption {
	return func(m *GroupAliasMutation) {
		m.oldValue = func(context.Context) (*GroupAlias, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupAliasMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupAliasMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("pjsk: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupAliasMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupAliasMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupAlias.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlatform sets the "platform" field.
func (m *GroupAliasMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *GroupAliasMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the GroupAlias entity.
// If the GroupAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupAliasMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *GroupAliasMutation) ResetPlatform() {
	m.platform = nil
}

// SetGroupID sets the "group_id" field.
func (m *GroupAliasMutation) SetGroupID(s string) {
	m.group_id = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *GroupAliasMutation) GroupID() (r string, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the GroupAlias entity.
// If the GroupAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupAliasMutation) OldGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *GroupAliasMutation) ResetGroupID() {
	m.group_id = nil
}

// SetAliasType sets the "alias_type" field.
func (m *GroupAliasMutation) SetAliasType(s string) {
	m.alias_type = &s
}

// AliasType returns the value of the "alias_type" field in the mutation.
func (m *GroupAliasMutation) AliasType() (r string, exists bool) {
	v := m.alias_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAliasType returns the old "alias_type" field's value of the GroupAlias entity.
// If the GroupAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupAliasMutation) OldAliasType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliasType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliasType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliasType: %w", err)
	}
	return oldValue.AliasType, nil
}

// ResetAliasType resets all changes to the "alias_type" field.
func (m *GroupAliasMutation) ResetAliasType() {
	m.alias_type = nil
}

// SetAliasTypeID sets the "alias_type_id" field.
func (m *GroupAliasMutation) SetAliasTypeID(i int) {
	m.alias_type_id = &i
	m.addalias_type_id = nil
}

// AliasTypeID returns the value of the "alias_type_id" field in the mutation.
func (m *GroupAliasMutation) AliasTypeID() (r int, exists bool) {
	v := m.alias_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAliasTypeID returns the old "alias_type_id" field's value of the GroupAlias entity.
// If the GroupAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupAliasMutation) OldAliasTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliasTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliasTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliasTypeID: %w", err)
	}
	return oldValue.AliasTypeID, nil
}

// AddAliasTypeID adds i to the "alias_type_id" field.
func (m *GroupAliasMutation) AddAliasTypeID(i int) {
	if m.addalias_type_id != nil {
		*m.addalias_type_id += i
	} else {
		m.addalias_type_id = &i
	}
}

// AddedAliasTypeID returns the value that was added to the "alias_type_id" field in this mutation.
func (m *GroupAliasMutation) AddedAliasTypeID() (r int, exists bool) {
	v := m.addalias_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAliasTypeID resets all changes to the "alias_type_id" field.
func (m *GroupAliasMutation) ResetAliasTypeID() {
	m.alias_type_id = nil
	m.addalias_type_id = nil
}

// SetAlias sets the "alias" field.
func (m *GroupAliasMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *GroupAliasMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the GroupAlias entity.
// If the GroupAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupAliasMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *GroupAliasMutation) ResetAlias() {
	m.alias = nil
}

// Where appends a list predicates to the GroupAliasMutation builder.
func (m *GroupAliasMutation) Where(ps ...predicate.GroupAlias) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupAliasMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupAliasMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupAlias, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupAliasMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupAliasMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupAlias).
func (m *GroupAliasMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupAliasMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.platform != nil {
		fields = append(fields, groupalias.FieldPlatform)
	}
	if m.group_id != nil {
		fields = append(fields, groupalias.FieldGroupID)
	}
	if m.alias_type != nil {
		fields = append(fields, groupalias.FieldAliasType)
	}
	if m.alias_type_id != nil {
		fields = append(fields, groupalias.FieldAliasTypeID)
	}
	if m.alias != nil {
		fields = append(fields, groupalias.FieldAlias)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupAliasMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupalias.FieldPlatform:
		return m.Platform()
	case groupalias.FieldGroupID:
		return m.GroupID()
	case groupalias.FieldAliasType:
		return m.AliasType()
	case groupalias.FieldAliasTypeID:
		return m.AliasTypeID()
	case groupalias.FieldAlias:
		return m.Alias()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupAliasMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupalias.FieldPlatform:
		return m.OldPlatform(ctx)
	case groupalias.FieldGroupID:
		return m.OldGroupID(ctx)
	case groupalias.FieldAliasType:
		return m.OldAliasType(ctx)
	case groupalias.FieldAliasTypeID:
		return m.OldAliasTypeID(ctx)
	case groupalias.FieldAlias:
		return m.OldAlias(ctx)
	}
	return nil, fmt.Errorf("unknown GroupAlias field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupAliasMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupalias.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case groupalias.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case groupalias.FieldAliasType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliasType(v)
		return nil
	case groupalias.FieldAliasTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliasTypeID(v)
		return nil
	case groupalias.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	}
	return fmt.Errorf("unknown GroupAlias field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupAliasMutation) AddedFields() []string {
	var fields []string
	if m.addalias_type_id != nil {
		fields = append(fields, groupalias.FieldAliasTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupAliasMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case groupalias.FieldAliasTypeID:
		return m.AddedAliasTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupAliasMutation) AddField(name string, value ent.Value) error {
	switch name {
	case groupalias.FieldAliasTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAliasTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown GroupAlias numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupAliasMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupAliasMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupAliasMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GroupAlias nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupAliasMutation) ResetField(name string) error {
	switch name {
	case groupalias.FieldPlatform:
		m.ResetPlatform()
		return nil
	case groupalias.FieldGroupID:
		m.ResetGroupID()
		return nil
	case groupalias.FieldAliasType:
		m.ResetAliasType()
		return nil
	case groupalias.FieldAliasTypeID:
		m.ResetAliasTypeID()
		return nil
	case groupalias.FieldAlias:
		m.ResetAlias()
		return nil
	}
	return fmt.Errorf("unknown GroupAlias field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupAliasMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupAliasMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupAliasMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupAliasMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupAliasMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupAliasMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupAliasMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GroupAlias unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupAliasMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GroupAlias edge %s", name)
}

// PendingAliasMutation represents an operation that mutates the PendingAlias nodes in the graph.
type PendingAliasMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	alias_type       *string
	alias_type_id    *int
	addalias_type_id *int
	alias            *string
	submitted_by     *string
	submitted_at     *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*PendingAlias, error)
	predicates       []predicate.PendingAlias
}

var _ ent.Mutation = (*PendingAliasMutation)(nil)

// pendingaliasOption allows management of the mutation configuration using functional options.
type pendingaliasOption func(*PendingAliasMutation)

// newPendingAliasMutation creates new mutation for the PendingAlias entity.
func newPendingAliasMutation(c config, op Op, opts ...pendingaliasOption) *PendingAliasMutation {
	m := &PendingAliasMutation{
		config:        c,
		op:            op,
		typ:           TypePendingAlias,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPendingAliasID sets the ID field of the mutation.
func withPendingAliasID(id int64) pendingaliasOption {
	return func(m *PendingAliasMutation) {
		var (
			err   error
			once  sync.Once
			value *PendingAlias
		)
		m.oldValue = func(ctx context.Context) (*PendingAlias, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PendingAlias.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPendingAlias sets the old PendingAlias of the mutation.
func withPendingAlias(node *PendingAlias) pendingaliasOption {
	return func(m *PendingAliasMutation) {
		m.oldValue = func(context.Context) (*PendingAlias, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PendingAliasMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PendingAliasMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("pjsk: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PendingAlias entities.
func (m *PendingAliasMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PendingAliasMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PendingAliasMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PendingAlias.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAliasType sets the "alias_type" field.
func (m *PendingAliasMutation) SetAliasType(s string) {
	m.alias_type = &s
}

// AliasType returns the value of the "alias_type" field in the mutation.
func (m *PendingAliasMutation) AliasType() (r string, exists bool) {
	v := m.alias_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAliasType returns the old "alias_type" field's value of the PendingAlias entity.
// If the PendingAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAliasMutation) OldAliasType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliasType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliasType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliasType: %w", err)
	}
	return oldValue.AliasType, nil
}

// ResetAliasType resets all changes to the "alias_type" field.
func (m *PendingAliasMutation) ResetAliasType() {
	m.alias_type = nil
}

// SetAliasTypeID sets the "alias_type_id" field.
func (m *PendingAliasMutation) SetAliasTypeID(i int) {
	m.alias_type_id = &i
	m.addalias_type_id = nil
}

// AliasTypeID returns the value of the "alias_type_id" field in the mutation.
func (m *PendingAliasMutation) AliasTypeID() (r int, exists bool) {
	v := m.alias_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAliasTypeID returns the old "alias_type_id" field's value of the PendingAlias entity.
// If the PendingAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAliasMutation) OldAliasTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliasTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliasTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliasTypeID: %w", err)
	}
	return oldValue.AliasTypeID, nil
}

// AddAliasTypeID adds i to the "alias_type_id" field.
func (m *PendingAliasMutation) AddAliasTypeID(i int) {
	if m.addalias_type_id != nil {
		*m.addalias_type_id += i
	} else {
		m.addalias_type_id = &i
	}
}

// AddedAliasTypeID returns the value that was added to the "alias_type_id" field in this mutation.
func (m *PendingAliasMutation) AddedAliasTypeID() (r int, exists bool) {
	v := m.addalias_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAliasTypeID resets all changes to the "alias_type_id" field.
func (m *PendingAliasMutation) ResetAliasTypeID() {
	m.alias_type_id = nil
	m.addalias_type_id = nil
}

// SetAlias sets the "alias" field.
func (m *PendingAliasMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *PendingAliasMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the PendingAlias entity.
// If the PendingAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAliasMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *PendingAliasMutation) ResetAlias() {
	m.alias = nil
}

// SetSubmittedBy sets the "submitted_by" field.
func (m *PendingAliasMutation) SetSubmittedBy(s string) {
	m.submitted_by = &s
}

// SubmittedBy returns the value of the "submitted_by" field in the mutation.
func (m *PendingAliasMutation) SubmittedBy() (r string, exists bool) {
	v := m.submitted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmittedBy returns the old "submitted_by" field's value of the PendingAlias entity.
// If the PendingAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAliasMutation) OldSubmittedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmittedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmittedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmittedBy: %w", err)
	}
	return oldValue.SubmittedBy, nil
}

// ResetSubmittedBy resets all changes to the "submitted_by" field.
func (m *PendingAliasMutation) ResetSubmittedBy() {
	m.submitted_by = nil
}

// SetSubmittedAt sets the "submitted_at" field.
func (m *PendingAliasMutation) SetSubmittedAt(t time.Time) {
	m.submitted_at = &t
}

// SubmittedAt returns the value of the "submitted_at" field in the mutation.
func (m *PendingAliasMutation) SubmittedAt() (r time.Time, exists bool) {
	v := m.submitted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmittedAt returns the old "submitted_at" field's value of the PendingAlias entity.
// If the PendingAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAliasMutation) OldSubmittedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmittedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmittedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmittedAt: %w", err)
	}
	return oldValue.SubmittedAt, nil
}

// ResetSubmittedAt resets all changes to the "submitted_at" field.
func (m *PendingAliasMutation) ResetSubmittedAt() {
	m.submitted_at = nil
}

// Where appends a list predicates to the PendingAliasMutation builder.
func (m *PendingAliasMutation) Where(ps ...predicate.PendingAlias) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PendingAliasMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PendingAliasMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PendingAlias, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PendingAliasMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PendingAliasMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PendingAlias).
func (m *PendingAliasMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PendingAliasMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.alias_type != nil {
		fields = append(fields, pendingalias.FieldAliasType)
	}
	if m.alias_type_id != nil {
		fields = append(fields, pendingalias.FieldAliasTypeID)
	}
	if m.alias != nil {
		fields = append(fields, pendingalias.FieldAlias)
	}
	if m.submitted_by != nil {
		fields = append(fields, pendingalias.FieldSubmittedBy)
	}
	if m.submitted_at != nil {
		fields = append(fields, pendingalias.FieldSubmittedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PendingAliasMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pendingalias.FieldAliasType:
		return m.AliasType()
	case pendingalias.FieldAliasTypeID:
		return m.AliasTypeID()
	case pendingalias.FieldAlias:
		return m.Alias()
	case pendingalias.FieldSubmittedBy:
		return m.SubmittedBy()
	case pendingalias.FieldSubmittedAt:
		return m.SubmittedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PendingAliasMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pendingalias.FieldAliasType:
		return m.OldAliasType(ctx)
	case pendingalias.FieldAliasTypeID:
		return m.OldAliasTypeID(ctx)
	case pendingalias.FieldAlias:
		return m.OldAlias(ctx)
	case pendingalias.FieldSubmittedBy:
		return m.OldSubmittedBy(ctx)
	case pendingalias.FieldSubmittedAt:
		return m.OldSubmittedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PendingAlias field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingAliasMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pendingalias.FieldAliasType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliasType(v)
		return nil
	case pendingalias.FieldAliasTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliasTypeID(v)
		return nil
	case pendingalias.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case pendingalias.FieldSubmittedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmittedBy(v)
		return nil
	case pendingalias.FieldSubmittedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmittedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PendingAlias field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PendingAliasMutation) AddedFields() []string {
	var fields []string
	if m.addalias_type_id != nil {
		fields = append(fields, pendingalias.FieldAliasTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PendingAliasMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pendingalias.FieldAliasTypeID:
		return m.AddedAliasTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingAliasMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pendingalias.FieldAliasTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAliasTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown PendingAlias numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PendingAliasMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PendingAliasMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PendingAliasMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PendingAlias nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PendingAliasMutation) ResetField(name string) error {
	switch name {
	case pendingalias.FieldAliasType:
		m.ResetAliasType()
		return nil
	case pendingalias.FieldAliasTypeID:
		m.ResetAliasTypeID()
		return nil
	case pendingalias.FieldAlias:
		m.ResetAlias()
		return nil
	case pendingalias.FieldSubmittedBy:
		m.ResetSubmittedBy()
		return nil
	case pendingalias.FieldSubmittedAt:
		m.ResetSubmittedAt()
		return nil
	}
	return fmt.Errorf("unknown PendingAlias field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PendingAliasMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PendingAliasMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PendingAliasMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PendingAliasMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PendingAliasMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PendingAliasMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PendingAliasMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PendingAlias unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PendingAliasMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PendingAlias edge %s", name)
}

// RejectedAliasMutation represents an operation that mutates the RejectedAlias nodes in the graph.
type RejectedAliasMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	alias_type       *string
	alias_type_id    *int
	addalias_type_id *int
	alias            *string
	reviewed_by      *string
	reason           *string
	reviewed_at      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*RejectedAlias, error)
	predicates       []predicate.RejectedAlias
}

var _ ent.Mutation = (*RejectedAliasMutation)(nil)

// rejectedaliasOption allows management of the mutation configuration using functional options.
type rejectedaliasOption func(*RejectedAliasMutation)

// newRejectedAliasMutation creates new mutation for the RejectedAlias entity.
func newRejectedAliasMutation(c config, op Op, opts ...rejectedaliasOption) *RejectedAliasMutation {
	m := &RejectedAliasMutation{
		config:        c,
		op:            op,
		typ:           TypeRejectedAlias,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRejectedAliasID sets the ID field of the mutation.
func withRejectedAliasID(id int64) rejectedaliasOption {
	return func(m *RejectedAliasMutation) {
		var (
			err   error
			once  sync.Once
			value *RejectedAlias
		)
		m.oldValue = func(ctx context.Context) (*RejectedAlias, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RejectedAlias.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRejectedAlias sets the old RejectedAlias of the mutation.
func withRejectedAlias(node *RejectedAlias) rejectedaliasOption {
	return func(m *RejectedAliasMutation) {
		m.oldValue = func(context.Context) (*RejectedAlias, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RejectedAliasMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RejectedAliasMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("pjsk: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RejectedAlias entities.
func (m *RejectedAliasMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RejectedAliasMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RejectedAliasMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RejectedAlias.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAliasType sets the "alias_type" field.
func (m *RejectedAliasMutation) SetAliasType(s string) {
	m.alias_type = &s
}

// AliasType returns the value of the "alias_type" field in the mutation.
func (m *RejectedAliasMutation) AliasType() (r string, exists bool) {
	v := m.alias_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAliasType returns the old "alias_type" field's value of the RejectedAlias entity.
// If the RejectedAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RejectedAliasMutation) OldAliasType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliasType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliasType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliasType: %w", err)
	}
	return oldValue.AliasType, nil
}

// ResetAliasType resets all changes to the "alias_type" field.
func (m *RejectedAliasMutation) ResetAliasType() {
	m.alias_type = nil
}

// SetAliasTypeID sets the "alias_type_id" field.
func (m *RejectedAliasMutation) SetAliasTypeID(i int) {
	m.alias_type_id = &i
	m.addalias_type_id = nil
}

// AliasTypeID returns the value of the "alias_type_id" field in the mutation.
func (m *RejectedAliasMutation) AliasTypeID() (r int, exists bool) {
	v := m.alias_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAliasTypeID returns the old "alias_type_id" field's value of the RejectedAlias entity.
// If the RejectedAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RejectedAliasMutation) OldAliasTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliasTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliasTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliasTypeID: %w", err)
	}
	return oldValue.AliasTypeID, nil
}

// AddAliasTypeID adds i to the "alias_type_id" field.
func (m *RejectedAliasMutation) AddAliasTypeID(i int) {
	if m.addalias_type_id != nil {
		*m.addalias_type_id += i
	} else {
		m.addalias_type_id = &i
	}
}

// AddedAliasTypeID returns the value that was added to the "alias_type_id" field in this mutation.
func (m *RejectedAliasMutation) AddedAliasTypeID() (r int, exists bool) {
	v := m.addalias_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAliasTypeID resets all changes to the "alias_type_id" field.
func (m *RejectedAliasMutation) ResetAliasTypeID() {
	m.alias_type_id = nil
	m.addalias_type_id = nil
}

// SetAlias sets the "alias" field.
func (m *RejectedAliasMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *RejectedAliasMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the RejectedAlias entity.
// If the RejectedAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RejectedAliasMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *RejectedAliasMutation) ResetAlias() {
	m.alias = nil
}

// SetReviewedBy sets the "reviewed_by" field.
func (m *RejectedAliasMutation) SetReviewedBy(s string) {
	m.reviewed_by = &s
}

// ReviewedBy returns the value of the "reviewed_by" field in the mutation.
func (m *RejectedAliasMutation) ReviewedBy() (r string, exists bool) {
	v := m.reviewed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedBy returns the old "reviewed_by" field's value of the RejectedAlias entity.
// If the RejectedAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RejectedAliasMutation) OldReviewedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedBy: %w", err)
	}
	return oldValue.ReviewedBy, nil
}

// ResetReviewedBy resets all changes to the "reviewed_by" field.
func (m *RejectedAliasMutation) ResetReviewedBy() {
	m.reviewed_by = nil
}

// SetReason sets the "reason" field.
func (m *RejectedAliasMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *RejectedAliasMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the RejectedAlias entity.
// If the RejectedAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RejectedAliasMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *RejectedAliasMutation) ResetReason() {
	m.reason = nil
}

// SetReviewedAt sets the "reviewed_at" field.
func (m *RejectedAliasMutation) SetReviewedAt(t time.Time) {
	m.reviewed_at = &t
}

// ReviewedAt returns the value of the "reviewed_at" field in the mutation.
func (m *RejectedAliasMutation) ReviewedAt() (r time.Time, exists bool) {
	v := m.reviewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedAt returns the old "reviewed_at" field's value of the RejectedAlias entity.
// If the RejectedAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RejectedAliasMutation) OldReviewedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedAt: %w", err)
	}
	return oldValue.ReviewedAt, nil
}

// ResetReviewedAt resets all changes to the "reviewed_at" field.
func (m *RejectedAliasMutation) ResetReviewedAt() {
	m.reviewed_at = nil
}

// Where appends a list predicates to the RejectedAliasMutation builder.
func (m *RejectedAliasMutation) Where(ps ...predicate.RejectedAlias) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RejectedAliasMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RejectedAliasMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RejectedAlias, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RejectedAliasMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RejectedAliasMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RejectedAlias).
func (m *RejectedAliasMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RejectedAliasMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.alias_type != nil {
		fields = append(fields, rejectedalias.FieldAliasType)
	}
	if m.alias_type_id != nil {
		fields = append(fields, rejectedalias.FieldAliasTypeID)
	}
	if m.alias != nil {
		fields = append(fields, rejectedalias.FieldAlias)
	}
	if m.reviewed_by != nil {
		fields = append(fields, rejectedalias.FieldReviewedBy)
	}
	if m.reason != nil {
		fields = append(fields, rejectedalias.FieldReason)
	}
	if m.reviewed_at != nil {
		fields = append(fields, rejectedalias.FieldReviewedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RejectedAliasMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rejectedalias.FieldAliasType:
		return m.AliasType()
	case rejectedalias.FieldAliasTypeID:
		return m.AliasTypeID()
	case rejectedalias.FieldAlias:
		return m.Alias()
	case rejectedalias.FieldReviewedBy:
		return m.ReviewedBy()
	case rejectedalias.FieldReason:
		return m.Reason()
	case rejectedalias.FieldReviewedAt:
		return m.ReviewedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RejectedAliasMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rejectedalias.FieldAliasType:
		return m.OldAliasType(ctx)
	case rejectedalias.FieldAliasTypeID:
		return m.OldAliasTypeID(ctx)
	case rejectedalias.FieldAlias:
		return m.OldAlias(ctx)
	case rejectedalias.FieldReviewedBy:
		return m.OldReviewedBy(ctx)
	case rejectedalias.FieldReason:
		return m.OldReason(ctx)
	case rejectedalias.FieldReviewedAt:
		return m.OldReviewedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RejectedAlias field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RejectedAliasMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rejectedalias.FieldAliasType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliasType(v)
		return nil
	case rejectedalias.FieldAliasTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliasTypeID(v)
		return nil
	case rejectedalias.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case rejectedalias.FieldReviewedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedBy(v)
		return nil
	case rejectedalias.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case rejectedalias.FieldReviewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RejectedAlias field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RejectedAliasMutation) AddedFields() []string {
	var fields []string
	if m.addalias_type_id != nil {
		fields = append(fields, rejectedalias.FieldAliasTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RejectedAliasMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rejectedalias.FieldAliasTypeID:
		return m.AddedAliasTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RejectedAliasMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rejectedalias.FieldAliasTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAliasTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown RejectedAlias numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RejectedAliasMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RejectedAliasMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RejectedAliasMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RejectedAlias nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RejectedAliasMutation) ResetField(name string) error {
	switch name {
	case rejectedalias.FieldAliasType:
		m.ResetAliasType()
		return nil
	case rejectedalias.FieldAliasTypeID:
		m.ResetAliasTypeID()
		return nil
	case rejectedalias.FieldAlias:
		m.ResetAlias()
		return nil
	case rejectedalias.FieldReviewedBy:
		m.ResetReviewedBy()
		return nil
	case rejectedalias.FieldReason:
		m.ResetReason()
		return nil
	case rejectedalias.FieldReviewedAt:
		m.ResetReviewedAt()
		return nil
	}
	return fmt.Errorf("unknown RejectedAlias field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RejectedAliasMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RejectedAliasMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RejectedAliasMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RejectedAliasMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RejectedAliasMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RejectedAliasMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RejectedAliasMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RejectedAlias unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RejectedAliasMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RejectedAlias edge %s", name)
}

// UserBindingMutation represents an operation that mutates the UserBinding nodes in the graph.
type UserBindingMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	platform            *string
	im_id               *string
	user_id             *string
	server              *string
	visible             *bool
	clearedFields       map[string]struct{}
	default_refs        map[int]struct{}
	removeddefault_refs map[int]struct{}
	cleareddefault_refs bool
	done                bool
	oldValue            func(context.Context) (*UserBinding, error)
	predicates          []predicate.UserBinding
}

var _ ent.Mutation = (*UserBindingMutation)(nil)

// userbindingOption allows management of the mutation configuration using functional options.
type userbindingOption func(*UserBindingMutation)

// newUserBindingMutation creates new mutation for the UserBinding entity.
func newUserBindingMutation(c config, op Op, opts ...userbindingOption) *UserBindingMutation {
	m := &UserBindingMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBindingID sets the ID field of the mutation.
func withUserBindingID(id int) userbindingOption {
	return func(m *UserBindingMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBinding
		)
		m.oldValue = func(ctx context.Context) (*UserBinding, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBinding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBinding sets the old UserBinding of the mutation.
func withUserBinding(node *UserBinding) userbindingOption {
	return func(m *UserBindingMutation) {
		m.oldValue = func(context.Context) (*UserBinding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("pjsk: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserBinding entities.
func (m *UserBindingMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBindingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBindingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBinding.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlatform sets the "platform" field.
func (m *UserBindingMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UserBindingMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the UserBinding entity.
// If the UserBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBindingMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UserBindingMutation) ResetPlatform() {
	m.platform = nil
}

// SetImID sets the "im_id" field.
func (m *UserBindingMutation) SetImID(s string) {
	m.im_id = &s
}

// ImID returns the value of the "im_id" field in the mutation.
func (m *UserBindingMutation) ImID() (r string, exists bool) {
	v := m.im_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImID returns the old "im_id" field's value of the UserBinding entity.
// If the UserBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBindingMutation) OldImID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImID: %w", err)
	}
	return oldValue.ImID, nil
}

// ResetImID resets all changes to the "im_id" field.
func (m *UserBindingMutation) ResetImID() {
	m.im_id = nil
}

// SetUserID sets the "user_id" field.
func (m *UserBindingMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserBindingMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserBinding entity.
// If the UserBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBindingMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserBindingMutation) ResetUserID() {
	m.user_id = nil
}

// SetServer sets the "server" field.
func (m *UserBindingMutation) SetServer(s string) {
	m.server = &s
}

// Server returns the value of the "server" field in the mutation.
func (m *UserBindingMutation) Server() (r string, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServer returns the old "server" field's value of the UserBinding entity.
// If the UserBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBindingMutation) OldServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServer: %w", err)
	}
	return oldValue.Server, nil
}

// ResetServer resets all changes to the "server" field.
func (m *UserBindingMutation) ResetServer() {
	m.server = nil
}

// SetVisible sets the "visible" field.
func (m *UserBindingMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *UserBindingMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the UserBinding entity.
// If the UserBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBindingMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ResetVisible resets all changes to the "visible" field.
func (m *UserBindingMutation) ResetVisible() {
	m.visible = nil
}

// AddDefaultRefIDs adds the "default_refs" edge to the UserDefaultBinding entity by ids.
func (m *UserBindingMutation) AddDefaultRefIDs(ids ...int) {
	if m.default_refs == nil {
		m.default_refs = make(map[int]struct{})
	}
	for i := range ids {
		m.default_refs[ids[i]] = struct{}{}
	}
}

// ClearDefaultRefs clears the "default_refs" edge to the UserDefaultBinding entity.
func (m *UserBindingMutation) ClearDefaultRefs() {
	m.cleareddefault_refs = true
}

// DefaultRefsCleared reports if the "default_refs" edge to the UserDefaultBinding entity was cleared.
func (m *UserBindingMutation) DefaultRefsCleared() bool {
	return m.cleareddefault_refs
}

// RemoveDefaultRefIDs removes the "default_refs" edge to the UserDefaultBinding entity by IDs.
func (m *UserBindingMutation) RemoveDefaultRefIDs(ids ...int) {
	if m.removeddefault_refs == nil {
		m.removeddefault_refs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.default_refs, ids[i])
		m.removeddefault_refs[ids[i]] = struct{}{}
	}
}

// RemovedDefaultRefs returns the removed IDs of the "default_refs" edge to the UserDefaultBinding entity.
func (m *UserBindingMutation) RemovedDefaultRefsIDs() (ids []int) {
	for id := range m.removeddefault_refs {
		ids = append(ids, id)
	}
	return
}

// DefaultRefsIDs returns the "default_refs" edge IDs in the mutation.
func (m *UserBindingMutation) DefaultRefsIDs() (ids []int) {
	for id := range m.default_refs {
		ids = append(ids, id)
	}
	return
}

// ResetDefaultRefs resets all changes to the "default_refs" edge.
func (m *UserBindingMutation) ResetDefaultRefs() {
	m.default_refs = nil
	m.cleareddefault_refs = false
	m.removeddefault_refs = nil
}

// Where appends a list predicates to the UserBindingMutation builder.
func (m *UserBindingMutation) Where(ps ...predicate.UserBinding) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBindingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBindingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBinding, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBindingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBindingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBinding).
func (m *UserBindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBindingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.platform != nil {
		fields = append(fields, userbinding.FieldPlatform)
	}
	if m.im_id != nil {
		fields = append(fields, userbinding.FieldImID)
	}
	if m.user_id != nil {
		fields = append(fields, userbinding.FieldUserID)
	}
	if m.server != nil {
		fields = append(fields, userbinding.FieldServer)
	}
	if m.visible != nil {
		fields = append(fields, userbinding.FieldVisible)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userbinding.FieldPlatform:
		return m.Platform()
	case userbinding.FieldImID:
		return m.ImID()
	case userbinding.FieldUserID:
		return m.UserID()
	case userbinding.FieldServer:
		return m.Server()
	case userbinding.FieldVisible:
		return m.Visible()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userbinding.FieldPlatform:
		return m.OldPlatform(ctx)
	case userbinding.FieldImID:
		return m.OldImID(ctx)
	case userbinding.FieldUserID:
		return m.OldUserID(ctx)
	case userbinding.FieldServer:
		return m.OldServer(ctx)
	case userbinding.FieldVisible:
		return m.OldVisible(ctx)
	}
	return nil, fmt.Errorf("unknown UserBinding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userbinding.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case userbinding.FieldImID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImID(v)
		return nil
	case userbinding.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userbinding.FieldServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServer(v)
		return nil
	case userbinding.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	}
	return fmt.Errorf("unknown UserBinding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBindingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBindingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserBinding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBindingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBindingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserBinding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBindingMutation) ResetField(name string) error {
	switch name {
	case userbinding.FieldPlatform:
		m.ResetPlatform()
		return nil
	case userbinding.FieldImID:
		m.ResetImID()
		return nil
	case userbinding.FieldUserID:
		m.ResetUserID()
		return nil
	case userbinding.FieldServer:
		m.ResetServer()
		return nil
	case userbinding.FieldVisible:
		m.ResetVisible()
		return nil
	}
	return fmt.Errorf("unknown UserBinding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.default_refs != nil {
		edges = append(edges, userbinding.EdgeDefaultRefs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBindingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userbinding.EdgeDefaultRefs:
		ids := make([]ent.Value, 0, len(m.default_refs))
		for id := range m.default_refs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddefault_refs != nil {
		edges = append(edges, userbinding.EdgeDefaultRefs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBindingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userbinding.EdgeDefaultRefs:
		ids := make([]ent.Value, 0, len(m.removeddefault_refs))
		for id := range m.removeddefault_refs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddefault_refs {
		edges = append(edges, userbinding.EdgeDefaultRefs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBindingMutation) EdgeCleared(name string) bool {
	switch name {
	case userbinding.EdgeDefaultRefs:
		return m.cleareddefault_refs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBindingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserBinding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBindingMutation) ResetEdge(name string) error {
	switch name {
	case userbinding.EdgeDefaultRefs:
		m.ResetDefaultRefs()
		return nil
	}
	return fmt.Errorf("unknown UserBinding edge %s", name)
}

// UserDefaultBindingMutation represents an operation that mutates the UserDefaultBinding nodes in the graph.
type UserDefaultBindingMutation struct {
	config
	op             Op
	typ            string
	id             *int
	im_id          *string
	platform       *string
	server         *string
	clearedFields  map[string]struct{}
	binding        *int
	clearedbinding bool
	done           bool
	oldValue       func(context.Context) (*UserDefaultBinding, error)
	predicates     []predicate.UserDefaultBinding
}

var _ ent.Mutation = (*UserDefaultBindingMutation)(nil)

// userdefaultbindingOption allows management of the mutation configuration using functional options.
type userdefaultbindingOption func(*UserDefaultBindingMutation)

// newUserDefaultBindingMutation creates new mutation for the UserDefaultBinding entity.
func newUserDefaultBindingMutation(c config, op Op, opts ...userdefaultbindingOption) *UserDefaultBindingMutation {
	m := &UserDefaultBindingMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDefaultBinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDefaultBindingID sets the ID field of the mutation.
func withUserDefaultBindingID(id int) userdefaultbindingOption {
	return func(m *UserDefaultBindingMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDefaultBinding
		)
		m.oldValue = func(ctx context.Context) (*UserDefaultBinding, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDefaultBinding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDefaultBinding sets the old UserDefaultBinding of the mutation.
func withUserDefaultBinding(node *UserDefaultBinding) userdefaultbindingOption {
	return func(m *UserDefaultBindingMutation) {
		m.oldValue = func(context.Context) (*UserDefaultBinding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDefaultBindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDefaultBindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("pjsk: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserDefaultBinding entities.
func (m *UserDefaultBindingMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserDefaultBindingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserDefaultBindingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserDefaultBinding.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImID sets the "im_id" field.
func (m *UserDefaultBindingMutation) SetImID(s string) {
	m.im_id = &s
}

// ImID returns the value of the "im_id" field in the mutation.
func (m *UserDefaultBindingMutation) ImID() (r string, exists bool) {
	v := m.im_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImID returns the old "im_id" field's value of the UserDefaultBinding entity.
// If the UserDefaultBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDefaultBindingMutation) OldImID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImID: %w", err)
	}
	return oldValue.ImID, nil
}

// ResetImID resets all changes to the "im_id" field.
func (m *UserDefaultBindingMutation) ResetImID() {
	m.im_id = nil
}

// SetPlatform sets the "platform" field.
func (m *UserDefaultBindingMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UserDefaultBindingMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the UserDefaultBinding entity.
// If the UserDefaultBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDefaultBindingMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UserDefaultBindingMutation) ResetPlatform() {
	m.platform = nil
}

// SetServer sets the "server" field.
func (m *UserDefaultBindingMutation) SetServer(s string) {
	m.server = &s
}

// Server returns the value of the "server" field in the mutation.
func (m *UserDefaultBindingMutation) Server() (r string, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServer returns the old "server" field's value of the UserDefaultBinding entity.
// If the UserDefaultBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDefaultBindingMutation) OldServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServer: %w", err)
	}
	return oldValue.Server, nil
}

// ResetServer resets all changes to the "server" field.
func (m *UserDefaultBindingMutation) ResetServer() {
	m.server = nil
}

// SetBindingID sets the "binding_id" field.
func (m *UserDefaultBindingMutation) SetBindingID(i int) {
	m.binding = &i
}

// BindingID returns the value of the "binding_id" field in the mutation.
func (m *UserDefaultBindingMutation) BindingID() (r int, exists bool) {
	v := m.binding
	if v == nil {
		return
	}
	return *v, true
}

// OldBindingID returns the old "binding_id" field's value of the UserDefaultBinding entity.
// If the UserDefaultBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDefaultBindingMutation) OldBindingID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBindingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBindingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBindingID: %w", err)
	}
	return oldValue.BindingID, nil
}

// ResetBindingID resets all changes to the "binding_id" field.
func (m *UserDefaultBindingMutation) ResetBindingID() {
	m.binding = nil
}

// ClearBinding clears the "binding" edge to the UserBinding entity.
func (m *UserDefaultBindingMutation) ClearBinding() {
	m.clearedbinding = true
	m.clearedFields[userdefaultbinding.FieldBindingID] = struct{}{}
}

// BindingCleared reports if the "binding" edge to the UserBinding entity was cleared.
func (m *UserDefaultBindingMutation) BindingCleared() bool {
	return m.clearedbinding
}

// BindingIDs returns the "binding" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BindingID instead. It exists only for internal usage by the builders.
func (m *UserDefaultBindingMutation) BindingIDs() (ids []int) {
	if id := m.binding; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBinding resets all changes to the "binding" edge.
func (m *UserDefaultBindingMutation) ResetBinding() {
	m.binding = nil
	m.clearedbinding = false
}

// Where appends a list predicates to the UserDefaultBindingMutation builder.
func (m *UserDefaultBindingMutation) Where(ps ...predicate.UserDefaultBinding) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserDefaultBindingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserDefaultBindingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserDefaultBinding, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserDefaultBindingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserDefaultBindingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserDefaultBinding).
func (m *UserDefaultBindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserDefaultBindingMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.im_id != nil {
		fields = append(fields, userdefaultbinding.FieldImID)
	}
	if m.platform != nil {
		fields = append(fields, userdefaultbinding.FieldPlatform)
	}
	if m.server != nil {
		fields = append(fields, userdefaultbinding.FieldServer)
	}
	if m.binding != nil {
		fields = append(fields, userdefaultbinding.FieldBindingID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserDefaultBindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdefaultbinding.FieldImID:
		return m.ImID()
	case userdefaultbinding.FieldPlatform:
		return m.Platform()
	case userdefaultbinding.FieldServer:
		return m.Server()
	case userdefaultbinding.FieldBindingID:
		return m.BindingID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserDefaultBindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdefaultbinding.FieldImID:
		return m.OldImID(ctx)
	case userdefaultbinding.FieldPlatform:
		return m.OldPlatform(ctx)
	case userdefaultbinding.FieldServer:
		return m.OldServer(ctx)
	case userdefaultbinding.FieldBindingID:
		return m.OldBindingID(ctx)
	}
	return nil, fmt.Errorf("unknown UserDefaultBinding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDefaultBindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdefaultbinding.FieldImID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImID(v)
		return nil
	case userdefaultbinding.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case userdefaultbinding.FieldServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServer(v)
		return nil
	case userdefaultbinding.FieldBindingID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBindingID(v)
		return nil
	}
	return fmt.Errorf("unknown UserDefaultBinding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserDefaultBindingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserDefaultBindingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDefaultBindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserDefaultBinding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserDefaultBindingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserDefaultBindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDefaultBindingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserDefaultBinding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserDefaultBindingMutation) ResetField(name string) error {
	switch name {
	case userdefaultbinding.FieldImID:
		m.ResetImID()
		return nil
	case userdefaultbinding.FieldPlatform:
		m.ResetPlatform()
		return nil
	case userdefaultbinding.FieldServer:
		m.ResetServer()
		return nil
	case userdefaultbinding.FieldBindingID:
		m.ResetBindingID()
		return nil
	}
	return fmt.Errorf("unknown UserDefaultBinding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserDefaultBindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.binding != nil {
		edges = append(edges, userdefaultbinding.EdgeBinding)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserDefaultBindingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userdefaultbinding.EdgeBinding:
		if id := m.binding; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserDefaultBindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserDefaultBindingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserDefaultBindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbinding {
		edges = append(edges, userdefaultbinding.EdgeBinding)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserDefaultBindingMutation) EdgeCleared(name string) bool {
	switch name {
	case userdefaultbinding.EdgeBinding:
		return m.clearedbinding
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserDefaultBindingMutation) ClearEdge(name string) error {
	switch name {
	case userdefaultbinding.EdgeBinding:
		m.ClearBinding()
		return nil
	}
	return fmt.Errorf("unknown UserDefaultBinding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserDefaultBindingMutation) ResetEdge(name string) error {
	switch name {
	case userdefaultbinding.EdgeBinding:
		m.ResetBinding()
		return nil
	}
	return fmt.Errorf("unknown UserDefaultBinding edge %s", name)
}

// UserPreferenceMutation represents an operation that mutates the UserPreference nodes in the graph.
type UserPreferenceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	im_id         *string
	platform      *string
	option        *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserPreference, error)
	predicates    []predicate.UserPreference
}

var _ ent.Mutation = (*UserPreferenceMutation)(nil)

// userpreferenceOption allows management of the mutation configuration using functional options.
type userpreferenceOption func(*UserPreferenceMutation)

// newUserPreferenceMutation creates new mutation for the UserPreference entity.
func newUserPreferenceMutation(c config, op Op, opts ...userpreferenceOption) *UserPreferenceMutation {
	m := &UserPreferenceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPreference,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPreferenceID sets the ID field of the mutation.
func withUserPreferenceID(id int) userpreferenceOption {
	return func(m *UserPreferenceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPreference
		)
		m.oldValue = func(ctx context.Context) (*UserPreference, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPreference.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPreference sets the old UserPreference of the mutation.
func withUserPreference(node *UserPreference) userpreferenceOption {
	return func(m *UserPreferenceMutation) {
		m.oldValue = func(context.Context) (*UserPreference, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPreferenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPreferenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("pjsk: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPreferenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPreferenceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPreference.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImID sets the "im_id" field.
func (m *UserPreferenceMutation) SetImID(s string) {
	m.im_id = &s
}

// ImID returns the value of the "im_id" field in the mutation.
func (m *UserPreferenceMutation) ImID() (r string, exists bool) {
	v := m.im_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImID returns the old "im_id" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldImID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImID: %w", err)
	}
	return oldValue.ImID, nil
}

// ResetImID resets all changes to the "im_id" field.
func (m *UserPreferenceMutation) ResetImID() {
	m.im_id = nil
}

// SetPlatform sets the "platform" field.
func (m *UserPreferenceMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UserPreferenceMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UserPreferenceMutation) ResetPlatform() {
	m.platform = nil
}

// SetOption sets the "option" field.
func (m *UserPreferenceMutation) SetOption(s string) {
	m.option = &s
}

// Option returns the value of the "option" field in the mutation.
func (m *UserPreferenceMutation) Option() (r string, exists bool) {
	v := m.option
	if v == nil {
		return
	}
	return *v, true
}

// OldOption returns the old "option" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldOption(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOption: %w", err)
	}
	return oldValue.Option, nil
}

// ResetOption resets all changes to the "option" field.
func (m *UserPreferenceMutation) ResetOption() {
	m.option = nil
}

// SetValue sets the "value" field.
func (m *UserPreferenceMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *UserPreferenceMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *UserPreferenceMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the UserPreferenceMutation builder.
func (m *UserPreferenceMutation) Where(ps ...predicate.UserPreference) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPreferenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPreferenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPreference, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPreferenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPreferenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPreference).
func (m *UserPreferenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPreferenceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.im_id != nil {
		fields = append(fields, userpreference.FieldImID)
	}
	if m.platform != nil {
		fields = append(fields, userpreference.FieldPlatform)
	}
	if m.option != nil {
		fields = append(fields, userpreference.FieldOption)
	}
	if m.value != nil {
		fields = append(fields, userpreference.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPreferenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpreference.FieldImID:
		return m.ImID()
	case userpreference.FieldPlatform:
		return m.Platform()
	case userpreference.FieldOption:
		return m.Option()
	case userpreference.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPreferenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpreference.FieldImID:
		return m.OldImID(ctx)
	case userpreference.FieldPlatform:
		return m.OldPlatform(ctx)
	case userpreference.FieldOption:
		return m.OldOption(ctx)
	case userpreference.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown UserPreference field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPreferenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpreference.FieldImID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImID(v)
		return nil
	case userpreference.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case userpreference.FieldOption:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOption(v)
		return nil
	case userpreference.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown UserPreference field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPreferenceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPreferenceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPreferenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserPreference numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPreferenceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPreferenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPreferenceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserPreference nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPreferenceMutation) ResetField(name string) error {
	switch name {
	case userpreference.FieldImID:
		m.ResetImID()
		return nil
	case userpreference.FieldPlatform:
		m.ResetPlatform()
		return nil
	case userpreference.FieldOption:
		m.ResetOption()
		return nil
	case userpreference.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown UserPreference field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPreferenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPreferenceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPreferenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPreferenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPreferenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPreferenceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPreferenceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserPreference unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPreferenceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserPreference edge %s", name)
}
