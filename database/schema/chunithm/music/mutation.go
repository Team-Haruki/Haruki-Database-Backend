// Code generated by ent, DO NOT EDIT.

package music

import (
	"context"
	"errors"
	"fmt"
	"haruki-database/database/schema/chunithm/music/chunithmchartdata"
	"haruki-database/database/schema/chunithm/music/chunithmmusic"
	"haruki-database/database/schema/chunithm/music/chunithmmusicdifficulty"
	"haruki-database/database/schema/chunithm/music/predicate"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeChunithmChartData       = "ChunithmChartData"
	TypeChunithmMusic           = "ChunithmMusic"
	TypeChunithmMusicDifficulty = "ChunithmMusicDifficulty"
)

// ChunithmChartDataMutation represents an operation that mutates the ChunithmChartData nodes in the graph.
type ChunithmChartDataMutation struct {
	config
	op             Op
	typ            string
	id             *int
	music_id       *int
	addmusic_id    *int
	difficulty     *int
	adddifficulty  *int
	creator        *string
	bpm            *float64
	addbpm         *float64
	tap_count      *int
	addtap_count   *int
	hold_count     *int
	addhold_count  *int
	slide_count    *int
	addslide_count *int
	air_count      *int
	addair_count   *int
	flick_count    *int
	addflick_count *int
	total_count    *int
	addtotal_count *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ChunithmChartData, error)
	predicates     []predicate.ChunithmChartData
}

var _ ent.Mutation = (*ChunithmChartDataMutation)(nil)

// chunithmchartdataOption allows management of the mutation configuration using functional options.
type chunithmchartdataOption func(*ChunithmChartDataMutation)

// newChunithmChartDataMutation creates new mutation for the ChunithmChartData entity.
func newChunithmChartDataMutation(c config, op Op, opts ...chunithmchartdataOption) *ChunithmChartDataMutation {
	m := &ChunithmChartDataMutation{
		config:        c,
		op:            op,
		typ:           TypeChunithmChartData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChunithmChartDataID sets the ID field of the mutation.
func withChunithmChartDataID(id int) chunithmchartdataOption {
	return func(m *ChunithmChartDataMutation) {
		var (
			err   error
			once  sync.Once
			value *ChunithmChartData
		)
		m.oldValue = func(ctx context.Context) (*ChunithmChartData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChunithmChartData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChunithmChartData sets the old ChunithmChartData of the mutation.
func withChunithmChartData(node *ChunithmChartData) chunithmchartdataOption {
	return func(m *ChunithmChartDataMutation) {
		m.oldValue = func(context.Context) (*ChunithmChartData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChunithmChartDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChunithmChartDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("music: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChunithmChartDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChunithmChartDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChunithmChartData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMusicID sets the "music_id" field.
func (m *ChunithmChartDataMutation) SetMusicID(i int) {
	m.music_id = &i
	m.addmusic_id = nil
}

// MusicID returns the value of the "music_id" field in the mutation.
func (m *ChunithmChartDataMutation) MusicID() (r int, exists bool) {
	v := m.music_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicID returns the old "music_id" field's value of the ChunithmChartData entity.
// If the ChunithmChartData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmChartDataMutation) OldMusicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMusicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMusicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicID: %w", err)
	}
	return oldValue.MusicID, nil
}

// AddMusicID adds i to the "music_id" field.
func (m *ChunithmChartDataMutation) AddMusicID(i int) {
	if m.addmusic_id != nil {
		*m.addmusic_id += i
	} else {
		m.addmusic_id = &i
	}
}

// AddedMusicID returns the value that was added to the "music_id" field in this mutation.
func (m *ChunithmChartDataMutation) AddedMusicID() (r int, exists bool) {
	v := m.addmusic_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMusicID resets all changes to the "music_id" field.
func (m *ChunithmChartDataMutation) ResetMusicID() {
	m.music_id = nil
	m.addmusic_id = nil
}

// SetDifficulty sets the "difficulty" field.
func (m *ChunithmChartDataMutation) SetDifficulty(i int) {
	m.difficulty = &i
	m.adddifficulty = nil
}

// Difficulty returns the value of the "difficulty" field in the mutation.
func (m *ChunithmChartDataMutation) Difficulty() (r int, exists bool) {
	v := m.difficulty
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficulty returns the old "difficulty" field's value of the ChunithmChartData entity.
// If the ChunithmChartData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmChartDataMutation) OldDifficulty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDifficulty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDifficulty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficulty: %w", err)
	}
	return oldValue.Difficulty, nil
}

// AddDifficulty adds i to the "difficulty" field.
func (m *ChunithmChartDataMutation) AddDifficulty(i int) {
	if m.adddifficulty != nil {
		*m.adddifficulty += i
	} else {
		m.adddifficulty = &i
	}
}

// AddedDifficulty returns the value that was added to the "difficulty" field in this mutation.
func (m *ChunithmChartDataMutation) AddedDifficulty() (r int, exists bool) {
	v := m.adddifficulty
	if v == nil {
		return
	}
	return *v, true
}

// ResetDifficulty resets all changes to the "difficulty" field.
func (m *ChunithmChartDataMutation) ResetDifficulty() {
	m.difficulty = nil
	m.adddifficulty = nil
}

// SetCreator sets the "creator" field.
func (m *ChunithmChartDataMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ChunithmChartDataMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the ChunithmChartData entity.
// If the ChunithmChartData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmChartDataMutation) OldCreator(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ChunithmChartDataMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[chunithmchartdata.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ChunithmChartDataMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[chunithmchartdata.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ChunithmChartDataMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, chunithmchartdata.FieldCreator)
}

// SetBpm sets the "bpm" field.
func (m *ChunithmChartDataMutation) SetBpm(f float64) {
	m.bpm = &f
	m.addbpm = nil
}

// Bpm returns the value of the "bpm" field in the mutation.
func (m *ChunithmChartDataMutation) Bpm() (r float64, exists bool) {
	v := m.bpm
	if v == nil {
		return
	}
	return *v, true
}

// OldBpm returns the old "bpm" field's value of the ChunithmChartData entity.
// If the ChunithmChartData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmChartDataMutation) OldBpm(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBpm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBpm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBpm: %w", err)
	}
	return oldValue.Bpm, nil
}

// AddBpm adds f to the "bpm" field.
func (m *ChunithmChartDataMutation) AddBpm(f float64) {
	if m.addbpm != nil {
		*m.addbpm += f
	} else {
		m.addbpm = &f
	}
}

// AddedBpm returns the value that was added to the "bpm" field in this mutation.
func (m *ChunithmChartDataMutation) AddedBpm() (r float64, exists bool) {
	v := m.addbpm
	if v == nil {
		return
	}
	return *v, true
}

// ClearBpm clears the value of the "bpm" field.
func (m *ChunithmChartDataMutation) ClearBpm() {
	m.bpm = nil
	m.addbpm = nil
	m.clearedFields[chunithmchartdata.FieldBpm] = struct{}{}
}

// BpmCleared returns if the "bpm" field was cleared in this mutation.
func (m *ChunithmChartDataMutation) BpmCleared() bool {
	_, ok := m.clearedFields[chunithmchartdata.FieldBpm]
	return ok
}

// ResetBpm resets all changes to the "bpm" field.
func (m *ChunithmChartDataMutation) ResetBpm() {
	m.bpm = nil
	m.addbpm = nil
	delete(m.clearedFields, chunithmchartdata.FieldBpm)
}

// SetTapCount sets the "tap_count" field.
func (m *ChunithmChartDataMutation) SetTapCount(i int) {
	m.tap_count = &i
	m.addtap_count = nil
}

// TapCount returns the value of the "tap_count" field in the mutation.
func (m *ChunithmChartDataMutation) TapCount() (r int, exists bool) {
	v := m.tap_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTapCount returns the old "tap_count" field's value of the ChunithmChartData entity.
// If the ChunithmChartData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmChartDataMutation) OldTapCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTapCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTapCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTapCount: %w", err)
	}
	return oldValue.TapCount, nil
}

// AddTapCount adds i to the "tap_count" field.
func (m *ChunithmChartDataMutation) AddTapCount(i int) {
	if m.addtap_count != nil {
		*m.addtap_count += i
	} else {
		m.addtap_count = &i
	}
}

// AddedTapCount returns the value that was added to the "tap_count" field in this mutation.
func (m *ChunithmChartDataMutation) AddedTapCount() (r int, exists bool) {
	v := m.addtap_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTapCount clears the value of the "tap_count" field.
func (m *ChunithmChartDataMutation) ClearTapCount() {
	m.tap_count = nil
	m.addtap_count = nil
	m.clearedFields[chunithmchartdata.FieldTapCount] = struct{}{}
}

// TapCountCleared returns if the "tap_count" field was cleared in this mutation.
func (m *ChunithmChartDataMutation) TapCountCleared() bool {
	_, ok := m.clearedFields[chunithmchartdata.FieldTapCount]
	return ok
}

// ResetTapCount resets all changes to the "tap_count" field.
func (m *ChunithmChartDataMutation) ResetTapCount() {
	m.tap_count = nil
	m.addtap_count = nil
	delete(m.clearedFields, chunithmchartdata.FieldTapCount)
}

// SetHoldCount sets the "hold_count" field.
func (m *ChunithmChartDataMutation) SetHoldCount(i int) {
	m.hold_count = &i
	m.addhold_count = nil
}

// HoldCount returns the value of the "hold_count" field in the mutation.
func (m *ChunithmChartDataMutation) HoldCount() (r int, exists bool) {
	v := m.hold_count
	if v == nil {
		return
	}
	return *v, true
}

// OldHoldCount returns the old "hold_count" field's value of the ChunithmChartData entity.
// If the ChunithmChartData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmChartDataMutation) OldHoldCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHoldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHoldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHoldCount: %w", err)
	}
	return oldValue.HoldCount, nil
}

// AddHoldCount adds i to the "hold_count" field.
func (m *ChunithmChartDataMutation) AddHoldCount(i int) {
	if m.addhold_count != nil {
		*m.addhold_count += i
	} else {
		m.addhold_count = &i
	}
}

// AddedHoldCount returns the value that was added to the "hold_count" field in this mutation.
func (m *ChunithmChartDataMutation) AddedHoldCount() (r int, exists bool) {
	v := m.addhold_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearHoldCount clears the value of the "hold_count" field.
func (m *ChunithmChartDataMutation) ClearHoldCount() {
	m.hold_count = nil
	m.addhold_count = nil
	m.clearedFields[chunithmchartdata.FieldHoldCount] = struct{}{}
}

// HoldCountCleared returns if the "hold_count" field was cleared in this mutation.
func (m *ChunithmChartDataMutation) HoldCountCleared() bool {
	_, ok := m.clearedFields[chunithmchartdata.FieldHoldCount]
	return ok
}

// ResetHoldCount resets all changes to the "hold_count" field.
func (m *ChunithmChartDataMutation) ResetHoldCount() {
	m.hold_count = nil
	m.addhold_count = nil
	delete(m.clearedFields, chunithmchartdata.FieldHoldCount)
}

// SetSlideCount sets the "slide_count" field.
func (m *ChunithmChartDataMutation) SetSlideCount(i int) {
	m.slide_count = &i
	m.addslide_count = nil
}

// SlideCount returns the value of the "slide_count" field in the mutation.
func (m *ChunithmChartDataMutation) SlideCount() (r int, exists bool) {
	v := m.slide_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSlideCount returns the old "slide_count" field's value of the ChunithmChartData entity.
// If the ChunithmChartData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmChartDataMutation) OldSlideCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlideCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlideCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlideCount: %w", err)
	}
	return oldValue.SlideCount, nil
}

// AddSlideCount adds i to the "slide_count" field.
func (m *ChunithmChartDataMutation) AddSlideCount(i int) {
	if m.addslide_count != nil {
		*m.addslide_count += i
	} else {
		m.addslide_count = &i
	}
}

// AddedSlideCount returns the value that was added to the "slide_count" field in this mutation.
func (m *ChunithmChartDataMutation) AddedSlideCount() (r int, exists bool) {
	v := m.addslide_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearSlideCount clears the value of the "slide_count" field.
func (m *ChunithmChartDataMutation) ClearSlideCount() {
	m.slide_count = nil
	m.addslide_count = nil
	m.clearedFields[chunithmchartdata.FieldSlideCount] = struct{}{}
}

// SlideCountCleared returns if the "slide_count" field was cleared in this mutation.
func (m *ChunithmChartDataMutation) SlideCountCleared() bool {
	_, ok := m.clearedFields[chunithmchartdata.FieldSlideCount]
	return ok
}

// ResetSlideCount resets all changes to the "slide_count" field.
func (m *ChunithmChartDataMutation) ResetSlideCount() {
	m.slide_count = nil
	m.addslide_count = nil
	delete(m.clearedFields, chunithmchartdata.FieldSlideCount)
}

// SetAirCount sets the "air_count" field.
func (m *ChunithmChartDataMutation) SetAirCount(i int) {
	m.air_count = &i
	m.addair_count = nil
}

// AirCount returns the value of the "air_count" field in the mutation.
func (m *ChunithmChartDataMutation) AirCount() (r int, exists bool) {
	v := m.air_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAirCount returns the old "air_count" field's value of the ChunithmChartData entity.
// If the ChunithmChartData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmChartDataMutation) OldAirCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAirCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAirCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAirCount: %w", err)
	}
	return oldValue.AirCount, nil
}

// AddAirCount adds i to the "air_count" field.
func (m *ChunithmChartDataMutation) AddAirCount(i int) {
	if m.addair_count != nil {
		*m.addair_count += i
	} else {
		m.addair_count = &i
	}
}

// AddedAirCount returns the value that was added to the "air_count" field in this mutation.
func (m *ChunithmChartDataMutation) AddedAirCount() (r int, exists bool) {
	v := m.addair_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearAirCount clears the value of the "air_count" field.
func (m *ChunithmChartDataMutation) ClearAirCount() {
	m.air_count = nil
	m.addair_count = nil
	m.clearedFields[chunithmchartdata.FieldAirCount] = struct{}{}
}

// AirCountCleared returns if the "air_count" field was cleared in this mutation.
func (m *ChunithmChartDataMutation) AirCountCleared() bool {
	_, ok := m.clearedFields[chunithmchartdata.FieldAirCount]
	return ok
}

// ResetAirCount resets all changes to the "air_count" field.
func (m *ChunithmChartDataMutation) ResetAirCount() {
	m.air_count = nil
	m.addair_count = nil
	delete(m.clearedFields, chunithmchartdata.FieldAirCount)
}

// SetFlickCount sets the "flick_count" field.
func (m *ChunithmChartDataMutation) SetFlickCount(i int) {
	m.flick_count = &i
	m.addflick_count = nil
}

// FlickCount returns the value of the "flick_count" field in the mutation.
func (m *ChunithmChartDataMutation) FlickCount() (r int, exists bool) {
	v := m.flick_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFlickCount returns the old "flick_count" field's value of the ChunithmChartData entity.
// If the ChunithmChartData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmChartDataMutation) OldFlickCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlickCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlickCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlickCount: %w", err)
	}
	return oldValue.FlickCount, nil
}

// AddFlickCount adds i to the "flick_count" field.
func (m *ChunithmChartDataMutation) AddFlickCount(i int) {
	if m.addflick_count != nil {
		*m.addflick_count += i
	} else {
		m.addflick_count = &i
	}
}

// AddedFlickCount returns the value that was added to the "flick_count" field in this mutation.
func (m *ChunithmChartDataMutation) AddedFlickCount() (r int, exists bool) {
	v := m.addflick_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearFlickCount clears the value of the "flick_count" field.
func (m *ChunithmChartDataMutation) ClearFlickCount() {
	m.flick_count = nil
	m.addflick_count = nil
	m.clearedFields[chunithmchartdata.FieldFlickCount] = struct{}{}
}

// FlickCountCleared returns if the "flick_count" field was cleared in this mutation.
func (m *ChunithmChartDataMutation) FlickCountCleared() bool {
	_, ok := m.clearedFields[chunithmchartdata.FieldFlickCount]
	return ok
}

// ResetFlickCount resets all changes to the "flick_count" field.
func (m *ChunithmChartDataMutation) ResetFlickCount() {
	m.flick_count = nil
	m.addflick_count = nil
	delete(m.clearedFields, chunithmchartdata.FieldFlickCount)
}

// SetTotalCount sets the "total_count" field.
func (m *ChunithmChartDataMutation) SetTotalCount(i int) {
	m.total_count = &i
	m.addtotal_count = nil
}

// TotalCount returns the value of the "total_count" field in the mutation.
func (m *ChunithmChartDataMutation) TotalCount() (r int, exists bool) {
	v := m.total_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCount returns the old "total_count" field's value of the ChunithmChartData entity.
// If the ChunithmChartData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmChartDataMutation) OldTotalCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCount: %w", err)
	}
	return oldValue.TotalCount, nil
}

// AddTotalCount adds i to the "total_count" field.
func (m *ChunithmChartDataMutation) AddTotalCount(i int) {
	if m.addtotal_count != nil {
		*m.addtotal_count += i
	} else {
		m.addtotal_count = &i
	}
}

// AddedTotalCount returns the value that was added to the "total_count" field in this mutation.
func (m *ChunithmChartDataMutation) AddedTotalCount() (r int, exists bool) {
	v := m.addtotal_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalCount clears the value of the "total_count" field.
func (m *ChunithmChartDataMutation) ClearTotalCount() {
	m.total_count = nil
	m.addtotal_count = nil
	m.clearedFields[chunithmchartdata.FieldTotalCount] = struct{}{}
}

// TotalCountCleared returns if the "total_count" field was cleared in this mutation.
func (m *ChunithmChartDataMutation) TotalCountCleared() bool {
	_, ok := m.clearedFields[chunithmchartdata.FieldTotalCount]
	return ok
}

// ResetTotalCount resets all changes to the "total_count" field.
func (m *ChunithmChartDataMutation) ResetTotalCount() {
	m.total_count = nil
	m.addtotal_count = nil
	delete(m.clearedFields, chunithmchartdata.FieldTotalCount)
}

// Where appends a list predicates to the ChunithmChartDataMutation builder.
func (m *ChunithmChartDataMutation) Where(ps ...predicate.ChunithmChartData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChunithmChartDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChunithmChartDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChunithmChartData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChunithmChartDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChunithmChartDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChunithmChartData).
func (m *ChunithmChartDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChunithmChartDataMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.music_id != nil {
		fields = append(fields, chunithmchartdata.FieldMusicID)
	}
	if m.difficulty != nil {
		fields = append(fields, chunithmchartdata.FieldDifficulty)
	}
	if m.creator != nil {
		fields = append(fields, chunithmchartdata.FieldCreator)
	}
	if m.bpm != nil {
		fields = append(fields, chunithmchartdata.FieldBpm)
	}
	if m.tap_count != nil {
		fields = append(fields, chunithmchartdata.FieldTapCount)
	}
	if m.hold_count != nil {
		fields = append(fields, chunithmchartdata.FieldHoldCount)
	}
	if m.slide_count != nil {
		fields = append(fields, chunithmchartdata.FieldSlideCount)
	}
	if m.air_count != nil {
		fields = append(fields, chunithmchartdata.FieldAirCount)
	}
	if m.flick_count != nil {
		fields = append(fields, chunithmchartdata.FieldFlickCount)
	}
	if m.total_count != nil {
		fields = append(fields, chunithmchartdata.FieldTotalCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChunithmChartDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chunithmchartdata.FieldMusicID:
		return m.MusicID()
	case chunithmchartdata.FieldDifficulty:
		return m.Difficulty()
	case chunithmchartdata.FieldCreator:
		return m.Creator()
	case chunithmchartdata.FieldBpm:
		return m.Bpm()
	case chunithmchartdata.FieldTapCount:
		return m.TapCount()
	case chunithmchartdata.FieldHoldCount:
		return m.HoldCount()
	case chunithmchartdata.FieldSlideCount:
		return m.SlideCount()
	case chunithmchartdata.FieldAirCount:
		return m.AirCount()
	case chunithmchartdata.FieldFlickCount:
		return m.FlickCount()
	case chunithmchartdata.FieldTotalCount:
		return m.TotalCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChunithmChartDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chunithmchartdata.FieldMusicID:
		return m.OldMusicID(ctx)
	case chunithmchartdata.FieldDifficulty:
		return m.OldDifficulty(ctx)
	case chunithmchartdata.FieldCreator:
		return m.OldCreator(ctx)
	case chunithmchartdata.FieldBpm:
		return m.OldBpm(ctx)
	case chunithmchartdata.FieldTapCount:
		return m.OldTapCount(ctx)
	case chunithmchartdata.FieldHoldCount:
		return m.OldHoldCount(ctx)
	case chunithmchartdata.FieldSlideCount:
		return m.OldSlideCount(ctx)
	case chunithmchartdata.FieldAirCount:
		return m.OldAirCount(ctx)
	case chunithmchartdata.FieldFlickCount:
		return m.OldFlickCount(ctx)
	case chunithmchartdata.FieldTotalCount:
		return m.OldTotalCount(ctx)
	}
	return nil, fmt.Errorf("unknown ChunithmChartData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChunithmChartDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chunithmchartdata.FieldMusicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicID(v)
		return nil
	case chunithmchartdata.FieldDifficulty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficulty(v)
		return nil
	case chunithmchartdata.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case chunithmchartdata.FieldBpm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBpm(v)
		return nil
	case chunithmchartdata.FieldTapCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTapCount(v)
		return nil
	case chunithmchartdata.FieldHoldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHoldCount(v)
		return nil
	case chunithmchartdata.FieldSlideCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlideCount(v)
		return nil
	case chunithmchartdata.FieldAirCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAirCount(v)
		return nil
	case chunithmchartdata.FieldFlickCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlickCount(v)
		return nil
	case chunithmchartdata.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCount(v)
		return nil
	}
	return fmt.Errorf("unknown ChunithmChartData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChunithmChartDataMutation) AddedFields() []string {
	var fields []string
	if m.addmusic_id != nil {
		fields = append(fields, chunithmchartdata.FieldMusicID)
	}
	if m.adddifficulty != nil {
		fields = append(fields, chunithmchartdata.FieldDifficulty)
	}
	if m.addbpm != nil {
		fields = append(fields, chunithmchartdata.FieldBpm)
	}
	if m.addtap_count != nil {
		fields = append(fields, chunithmchartdata.FieldTapCount)
	}
	if m.addhold_count != nil {
		fields = append(fields, chunithmchartdata.FieldHoldCount)
	}
	if m.addslide_count != nil {
		fields = append(fields, chunithmchartdata.FieldSlideCount)
	}
	if m.addair_count != nil {
		fields = append(fields, chunithmchartdata.FieldAirCount)
	}
	if m.addflick_count != nil {
		fields = append(fields, chunithmchartdata.FieldFlickCount)
	}
	if m.addtotal_count != nil {
		fields = append(fields, chunithmchartdata.FieldTotalCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChunithmChartDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chunithmchartdata.FieldMusicID:
		return m.AddedMusicID()
	case chunithmchartdata.FieldDifficulty:
		return m.AddedDifficulty()
	case chunithmchartdata.FieldBpm:
		return m.AddedBpm()
	case chunithmchartdata.FieldTapCount:
		return m.AddedTapCount()
	case chunithmchartdata.FieldHoldCount:
		return m.AddedHoldCount()
	case chunithmchartdata.FieldSlideCount:
		return m.AddedSlideCount()
	case chunithmchartdata.FieldAirCount:
		return m.AddedAirCount()
	case chunithmchartdata.FieldFlickCount:
		return m.AddedFlickCount()
	case chunithmchartdata.FieldTotalCount:
		return m.AddedTotalCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChunithmChartDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chunithmchartdata.FieldMusicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMusicID(v)
		return nil
	case chunithmchartdata.FieldDifficulty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDifficulty(v)
		return nil
	case chunithmchartdata.FieldBpm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBpm(v)
		return nil
	case chunithmchartdata.FieldTapCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTapCount(v)
		return nil
	case chunithmchartdata.FieldHoldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHoldCount(v)
		return nil
	case chunithmchartdata.FieldSlideCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSlideCount(v)
		return nil
	case chunithmchartdata.FieldAirCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAirCount(v)
		return nil
	case chunithmchartdata.FieldFlickCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFlickCount(v)
		return nil
	case chunithmchartdata.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCount(v)
		return nil
	}
	return fmt.Errorf("unknown ChunithmChartData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChunithmChartDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chunithmchartdata.FieldCreator) {
		fields = append(fields, chunithmchartdata.FieldCreator)
	}
	if m.FieldCleared(chunithmchartdata.FieldBpm) {
		fields = append(fields, chunithmchartdata.FieldBpm)
	}
	if m.FieldCleared(chunithmchartdata.FieldTapCount) {
		fields = append(fields, chunithmchartdata.FieldTapCount)
	}
	if m.FieldCleared(chunithmchartdata.FieldHoldCount) {
		fields = append(fields, chunithmchartdata.FieldHoldCount)
	}
	if m.FieldCleared(chunithmchartdata.FieldSlideCount) {
		fields = append(fields, chunithmchartdata.FieldSlideCount)
	}
	if m.FieldCleared(chunithmchartdata.FieldAirCount) {
		fields = append(fields, chunithmchartdata.FieldAirCount)
	}
	if m.FieldCleared(chunithmchartdata.FieldFlickCount) {
		fields = append(fields, chunithmchartdata.FieldFlickCount)
	}
	if m.FieldCleared(chunithmchartdata.FieldTotalCount) {
		fields = append(fields, chunithmchartdata.FieldTotalCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChunithmChartDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChunithmChartDataMutation) ClearField(name string) error {
	switch name {
	case chunithmchartdata.FieldCreator:
		m.ClearCreator()
		return nil
	case chunithmchartdata.FieldBpm:
		m.ClearBpm()
		return nil
	case chunithmchartdata.FieldTapCount:
		m.ClearTapCount()
		return nil
	case chunithmchartdata.FieldHoldCount:
		m.ClearHoldCount()
		return nil
	case chunithmchartdata.FieldSlideCount:
		m.ClearSlideCount()
		return nil
	case chunithmchartdata.FieldAirCount:
		m.ClearAirCount()
		return nil
	case chunithmchartdata.FieldFlickCount:
		m.ClearFlickCount()
		return nil
	case chunithmchartdata.FieldTotalCount:
		m.ClearTotalCount()
		return nil
	}
	return fmt.Errorf("unknown ChunithmChartData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChunithmChartDataMutation) ResetField(name string) error {
	switch name {
	case chunithmchartdata.FieldMusicID:
		m.ResetMusicID()
		return nil
	case chunithmchartdata.FieldDifficulty:
		m.ResetDifficulty()
		return nil
	case chunithmchartdata.FieldCreator:
		m.ResetCreator()
		return nil
	case chunithmchartdata.FieldBpm:
		m.ResetBpm()
		return nil
	case chunithmchartdata.FieldTapCount:
		m.ResetTapCount()
		return nil
	case chunithmchartdata.FieldHoldCount:
		m.ResetHoldCount()
		return nil
	case chunithmchartdata.FieldSlideCount:
		m.ResetSlideCount()
		return nil
	case chunithmchartdata.FieldAirCount:
		m.ResetAirCount()
		return nil
	case chunithmchartdata.FieldFlickCount:
		m.ResetFlickCount()
		return nil
	case chunithmchartdata.FieldTotalCount:
		m.ResetTotalCount()
		return nil
	}
	return fmt.Errorf("unknown ChunithmChartData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChunithmChartDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChunithmChartDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChunithmChartDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChunithmChartDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChunithmChartDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChunithmChartDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChunithmChartDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ChunithmChartData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChunithmChartDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ChunithmChartData edge %s", name)
}

// ChunithmMusicMutation represents an operation that mutates the ChunithmMusic nodes in the graph.
type ChunithmMusicMutation struct {
	config
	op              Op
	typ             string
	id              *int
	music_id        *int
	addmusic_id     *int
	title           *string
	artist          *string
	category        *string
	version         *string
	release_date    *time.Time
	is_deleted      *bool
	deleted_version *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ChunithmMusic, error)
	predicates      []predicate.ChunithmMusic
}

var _ ent.Mutation = (*ChunithmMusicMutation)(nil)

// chunithmmusicOption allows management of the mutation configuration using functional options.
type chunithmmusicOption func(*ChunithmMusicMutation)

// newChunithmMusicMutation creates new mutation for the ChunithmMusic entity.
func newChunithmMusicMutation(c config, op Op, opts ...chunithmmusicOption) *ChunithmMusicMutation {
	m := &ChunithmMusicMutation{
		config:        c,
		op:            op,
		typ:           TypeChunithmMusic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChunithmMusicID sets the ID field of the mutation.
func withChunithmMusicID(id int) chunithmmusicOption {
	return func(m *ChunithmMusicMutation) {
		var (
			err   error
			once  sync.Once
			value *ChunithmMusic
		)
		m.oldValue = func(ctx context.Context) (*ChunithmMusic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChunithmMusic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChunithmMusic sets the old ChunithmMusic of the mutation.
func withChunithmMusic(node *ChunithmMusic) chunithmmusicOption {
	return func(m *ChunithmMusicMutation) {
		m.oldValue = func(context.Context) (*ChunithmMusic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChunithmMusicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChunithmMusicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("music: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChunithmMusicMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChunithmMusicMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChunithmMusic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMusicID sets the "music_id" field.
func (m *ChunithmMusicMutation) SetMusicID(i int) {
	m.music_id = &i
	m.addmusic_id = nil
}

// MusicID returns the value of the "music_id" field in the mutation.
func (m *ChunithmMusicMutation) MusicID() (r int, exists bool) {
	v := m.music_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicID returns the old "music_id" field's value of the ChunithmMusic entity.
// If the ChunithmMusic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicMutation) OldMusicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMusicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMusicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicID: %w", err)
	}
	return oldValue.MusicID, nil
}

// AddMusicID adds i to the "music_id" field.
func (m *ChunithmMusicMutation) AddMusicID(i int) {
	if m.addmusic_id != nil {
		*m.addmusic_id += i
	} else {
		m.addmusic_id = &i
	}
}

// AddedMusicID returns the value that was added to the "music_id" field in this mutation.
func (m *ChunithmMusicMutation) AddedMusicID() (r int, exists bool) {
	v := m.addmusic_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMusicID resets all changes to the "music_id" field.
func (m *ChunithmMusicMutation) ResetMusicID() {
	m.music_id = nil
	m.addmusic_id = nil
}

// SetTitle sets the "title" field.
func (m *ChunithmMusicMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ChunithmMusicMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ChunithmMusic entity.
// If the ChunithmMusic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ChunithmMusicMutation) ResetTitle() {
	m.title = nil
}

// SetArtist sets the "artist" field.
func (m *ChunithmMusicMutation) SetArtist(s string) {
	m.artist = &s
}

// Artist returns the value of the "artist" field in the mutation.
func (m *ChunithmMusicMutation) Artist() (r string, exists bool) {
	v := m.artist
	if v == nil {
		return
	}
	return *v, true
}

// OldArtist returns the old "artist" field's value of the ChunithmMusic entity.
// If the ChunithmMusic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicMutation) OldArtist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtist: %w", err)
	}
	return oldValue.Artist, nil
}

// ResetArtist resets all changes to the "artist" field.
func (m *ChunithmMusicMutation) ResetArtist() {
	m.artist = nil
}

// SetCategory sets the "category" field.
func (m *ChunithmMusicMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ChunithmMusicMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ChunithmMusic entity.
// If the ChunithmMusic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicMutation) OldCategory(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ChunithmMusicMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[chunithmmusic.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ChunithmMusicMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[chunithmmusic.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ChunithmMusicMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, chunithmmusic.FieldCategory)
}

// SetVersion sets the "version" field.
func (m *ChunithmMusicMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ChunithmMusicMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ChunithmMusic entity.
// If the ChunithmMusic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicMutation) OldVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ChunithmMusicMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[chunithmmusic.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ChunithmMusicMutation) VersionCleared() bool {
	_, ok := m.clearedFields[chunithmmusic.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ChunithmMusicMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, chunithmmusic.FieldVersion)
}

// SetReleaseDate sets the "release_date" field.
func (m *ChunithmMusicMutation) SetReleaseDate(t time.Time) {
	m.release_date = &t
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *ChunithmMusicMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the ChunithmMusic entity.
// If the ChunithmMusic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicMutation) OldReleaseDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ClearReleaseDate clears the value of the "release_date" field.
func (m *ChunithmMusicMutation) ClearReleaseDate() {
	m.release_date = nil
	m.clearedFields[chunithmmusic.FieldReleaseDate] = struct{}{}
}

// ReleaseDateCleared returns if the "release_date" field was cleared in this mutation.
func (m *ChunithmMusicMutation) ReleaseDateCleared() bool {
	_, ok := m.clearedFields[chunithmmusic.FieldReleaseDate]
	return ok
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *ChunithmMusicMutation) ResetReleaseDate() {
	m.release_date = nil
	delete(m.clearedFields, chunithmmusic.FieldReleaseDate)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *ChunithmMusicMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *ChunithmMusicMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the ChunithmMusic entity.
// If the ChunithmMusic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *ChunithmMusicMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetDeletedVersion sets the "deleted_version" field.
func (m *ChunithmMusicMutation) SetDeletedVersion(s string) {
	m.deleted_version = &s
}

// DeletedVersion returns the value of the "deleted_version" field in the mutation.
func (m *ChunithmMusicMutation) DeletedVersion() (r string, exists bool) {
	v := m.deleted_version
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedVersion returns the old "deleted_version" field's value of the ChunithmMusic entity.
// If the ChunithmMusic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicMutation) OldDeletedVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedVersion: %w", err)
	}
	return oldValue.DeletedVersion, nil
}

// ClearDeletedVersion clears the value of the "deleted_version" field.
func (m *ChunithmMusicMutation) ClearDeletedVersion() {
	m.deleted_version = nil
	m.clearedFields[chunithmmusic.FieldDeletedVersion] = struct{}{}
}

// DeletedVersionCleared returns if the "deleted_version" field was cleared in this mutation.
func (m *ChunithmMusicMutation) DeletedVersionCleared() bool {
	_, ok := m.clearedFields[chunithmmusic.FieldDeletedVersion]
	return ok
}

// ResetDeletedVersion resets all changes to the "deleted_version" field.
func (m *ChunithmMusicMutation) ResetDeletedVersion() {
	m.deleted_version = nil
	delete(m.clearedFields, chunithmmusic.FieldDeletedVersion)
}

// Where appends a list predicates to the ChunithmMusicMutation builder.
func (m *ChunithmMusicMutation) Where(ps ...predicate.ChunithmMusic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChunithmMusicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChunithmMusicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChunithmMusic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChunithmMusicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChunithmMusicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChunithmMusic).
func (m *ChunithmMusicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChunithmMusicMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.music_id != nil {
		fields = append(fields, chunithmmusic.FieldMusicID)
	}
	if m.title != nil {
		fields = append(fields, chunithmmusic.FieldTitle)
	}
	if m.artist != nil {
		fields = append(fields, chunithmmusic.FieldArtist)
	}
	if m.category != nil {
		fields = append(fields, chunithmmusic.FieldCategory)
	}
	if m.version != nil {
		fields = append(fields, chunithmmusic.FieldVersion)
	}
	if m.release_date != nil {
		fields = append(fields, chunithmmusic.FieldReleaseDate)
	}
	if m.is_deleted != nil {
		fields = append(fields, chunithmmusic.FieldIsDeleted)
	}
	if m.deleted_version != nil {
		fields = append(fields, chunithmmusic.FieldDeletedVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChunithmMusicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chunithmmusic.FieldMusicID:
		return m.MusicID()
	case chunithmmusic.FieldTitle:
		return m.Title()
	case chunithmmusic.FieldArtist:
		return m.Artist()
	case chunithmmusic.FieldCategory:
		return m.Category()
	case chunithmmusic.FieldVersion:
		return m.Version()
	case chunithmmusic.FieldReleaseDate:
		return m.ReleaseDate()
	case chunithmmusic.FieldIsDeleted:
		return m.IsDeleted()
	case chunithmmusic.FieldDeletedVersion:
		return m.DeletedVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChunithmMusicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chunithmmusic.FieldMusicID:
		return m.OldMusicID(ctx)
	case chunithmmusic.FieldTitle:
		return m.OldTitle(ctx)
	case chunithmmusic.FieldArtist:
		return m.OldArtist(ctx)
	case chunithmmusic.FieldCategory:
		return m.OldCategory(ctx)
	case chunithmmusic.FieldVersion:
		return m.OldVersion(ctx)
	case chunithmmusic.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case chunithmmusic.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case chunithmmusic.FieldDeletedVersion:
		return m.OldDeletedVersion(ctx)
	}
	return nil, fmt.Errorf("unknown ChunithmMusic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChunithmMusicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chunithmmusic.FieldMusicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicID(v)
		return nil
	case chunithmmusic.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case chunithmmusic.FieldArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtist(v)
		return nil
	case chunithmmusic.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case chunithmmusic.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case chunithmmusic.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case chunithmmusic.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case chunithmmusic.FieldDeletedVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ChunithmMusic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChunithmMusicMutation) AddedFields() []string {
	var fields []string
	if m.addmusic_id != nil {
		fields = append(fields, chunithmmusic.FieldMusicID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChunithmMusicMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chunithmmusic.FieldMusicID:
		return m.AddedMusicID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChunithmMusicMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chunithmmusic.FieldMusicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMusicID(v)
		return nil
	}
	return fmt.Errorf("unknown ChunithmMusic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChunithmMusicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chunithmmusic.FieldCategory) {
		fields = append(fields, chunithmmusic.FieldCategory)
	}
	if m.FieldCleared(chunithmmusic.FieldVersion) {
		fields = append(fields, chunithmmusic.FieldVersion)
	}
	if m.FieldCleared(chunithmmusic.FieldReleaseDate) {
		fields = append(fields, chunithmmusic.FieldReleaseDate)
	}
	if m.FieldCleared(chunithmmusic.FieldDeletedVersion) {
		fields = append(fields, chunithmmusic.FieldDeletedVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChunithmMusicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChunithmMusicMutation) ClearField(name string) error {
	switch name {
	case chunithmmusic.FieldCategory:
		m.ClearCategory()
		return nil
	case chunithmmusic.FieldVersion:
		m.ClearVersion()
		return nil
	case chunithmmusic.FieldReleaseDate:
		m.ClearReleaseDate()
		return nil
	case chunithmmusic.FieldDeletedVersion:
		m.ClearDeletedVersion()
		return nil
	}
	return fmt.Errorf("unknown ChunithmMusic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChunithmMusicMutation) ResetField(name string) error {
	switch name {
	case chunithmmusic.FieldMusicID:
		m.ResetMusicID()
		return nil
	case chunithmmusic.FieldTitle:
		m.ResetTitle()
		return nil
	case chunithmmusic.FieldArtist:
		m.ResetArtist()
		return nil
	case chunithmmusic.FieldCategory:
		m.ResetCategory()
		return nil
	case chunithmmusic.FieldVersion:
		m.ResetVersion()
		return nil
	case chunithmmusic.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case chunithmmusic.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case chunithmmusic.FieldDeletedVersion:
		m.ResetDeletedVersion()
		return nil
	}
	return fmt.Errorf("unknown ChunithmMusic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChunithmMusicMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChunithmMusicMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChunithmMusicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChunithmMusicMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChunithmMusicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChunithmMusicMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChunithmMusicMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ChunithmMusic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChunithmMusicMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ChunithmMusic edge %s", name)
}

// ChunithmMusicDifficultyMutation represents an operation that mutates the ChunithmMusicDifficulty nodes in the graph.
type ChunithmMusicDifficultyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	music_id       *int
	addmusic_id    *int
	version        *string
	diff0_const    *float64
	adddiff0_const *float64
	diff1_const    *float64
	adddiff1_const *float64
	diff2_const    *float64
	adddiff2_const *float64
	diff3_const    *float64
	adddiff3_const *float64
	diff4_const    *float64
	adddiff4_const *float64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ChunithmMusicDifficulty, error)
	predicates     []predicate.ChunithmMusicDifficulty
}

var _ ent.Mutation = (*ChunithmMusicDifficultyMutation)(nil)

// chunithmmusicdifficultyOption allows management of the mutation configuration using functional options.
type chunithmmusicdifficultyOption func(*ChunithmMusicDifficultyMutation)

// newChunithmMusicDifficultyMutation creates new mutation for the ChunithmMusicDifficulty entity.
func newChunithmMusicDifficultyMutation(c config, op Op, opts ...chunithmmusicdifficultyOption) *ChunithmMusicDifficultyMutation {
	m := &ChunithmMusicDifficultyMutation{
		config:        c,
		op:            op,
		typ:           TypeChunithmMusicDifficulty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChunithmMusicDifficultyID sets the ID field of the mutation.
func withChunithmMusicDifficultyID(id int) chunithmmusicdifficultyOption {
	return func(m *ChunithmMusicDifficultyMutation) {
		var (
			err   error
			once  sync.Once
			value *ChunithmMusicDifficulty
		)
		m.oldValue = func(ctx context.Context) (*ChunithmMusicDifficulty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChunithmMusicDifficulty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChunithmMusicDifficulty sets the old ChunithmMusicDifficulty of the mutation.
func withChunithmMusicDifficulty(node *ChunithmMusicDifficulty) chunithmmusicdifficultyOption {
	return func(m *ChunithmMusicDifficultyMutation) {
		m.oldValue = func(context.Context) (*ChunithmMusicDifficulty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChunithmMusicDifficultyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChunithmMusicDifficultyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("music: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChunithmMusicDifficultyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChunithmMusicDifficultyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChunithmMusicDifficulty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMusicID sets the "music_id" field.
func (m *ChunithmMusicDifficultyMutation) SetMusicID(i int) {
	m.music_id = &i
	m.addmusic_id = nil
}

// MusicID returns the value of the "music_id" field in the mutation.
func (m *ChunithmMusicDifficultyMutation) MusicID() (r int, exists bool) {
	v := m.music_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicID returns the old "music_id" field's value of the ChunithmMusicDifficulty entity.
// If the ChunithmMusicDifficulty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicDifficultyMutation) OldMusicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMusicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMusicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicID: %w", err)
	}
	return oldValue.MusicID, nil
}

// AddMusicID adds i to the "music_id" field.
func (m *ChunithmMusicDifficultyMutation) AddMusicID(i int) {
	if m.addmusic_id != nil {
		*m.addmusic_id += i
	} else {
		m.addmusic_id = &i
	}
}

// AddedMusicID returns the value that was added to the "music_id" field in this mutation.
func (m *ChunithmMusicDifficultyMutation) AddedMusicID() (r int, exists bool) {
	v := m.addmusic_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMusicID resets all changes to the "music_id" field.
func (m *ChunithmMusicDifficultyMutation) ResetMusicID() {
	m.music_id = nil
	m.addmusic_id = nil
}

// SetVersion sets the "version" field.
func (m *ChunithmMusicDifficultyMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ChunithmMusicDifficultyMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ChunithmMusicDifficulty entity.
// If the ChunithmMusicDifficulty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicDifficultyMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ChunithmMusicDifficultyMutation) ResetVersion() {
	m.version = nil
}

// SetDiff0Const sets the "diff0_const" field.
func (m *ChunithmMusicDifficultyMutation) SetDiff0Const(f float64) {
	m.diff0_const = &f
	m.adddiff0_const = nil
}

// Diff0Const returns the value of the "diff0_const" field in the mutation.
func (m *ChunithmMusicDifficultyMutation) Diff0Const() (r float64, exists bool) {
	v := m.diff0_const
	if v == nil {
		return
	}
	return *v, true
}

// OldDiff0Const returns the old "diff0_const" field's value of the ChunithmMusicDifficulty entity.
// If the ChunithmMusicDifficulty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicDifficultyMutation) OldDiff0Const(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiff0Const is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiff0Const requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiff0Const: %w", err)
	}
	return oldValue.Diff0Const, nil
}

// AddDiff0Const adds f to the "diff0_const" field.
func (m *ChunithmMusicDifficultyMutation) AddDiff0Const(f float64) {
	if m.adddiff0_const != nil {
		*m.adddiff0_const += f
	} else {
		m.adddiff0_const = &f
	}
}

// AddedDiff0Const returns the value that was added to the "diff0_const" field in this mutation.
func (m *ChunithmMusicDifficultyMutation) AddedDiff0Const() (r float64, exists bool) {
	v := m.adddiff0_const
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiff0Const clears the value of the "diff0_const" field.
func (m *ChunithmMusicDifficultyMutation) ClearDiff0Const() {
	m.diff0_const = nil
	m.adddiff0_const = nil
	m.clearedFields[chunithmmusicdifficulty.FieldDiff0Const] = struct{}{}
}

// Diff0ConstCleared returns if the "diff0_const" field was cleared in this mutation.
func (m *ChunithmMusicDifficultyMutation) Diff0ConstCleared() bool {
	_, ok := m.clearedFields[chunithmmusicdifficulty.FieldDiff0Const]
	return ok
}

// ResetDiff0Const resets all changes to the "diff0_const" field.
func (m *ChunithmMusicDifficultyMutation) ResetDiff0Const() {
	m.diff0_const = nil
	m.adddiff0_const = nil
	delete(m.clearedFields, chunithmmusicdifficulty.FieldDiff0Const)
}

// SetDiff1Const sets the "diff1_const" field.
func (m *ChunithmMusicDifficultyMutation) SetDiff1Const(f float64) {
	m.diff1_const = &f
	m.adddiff1_const = nil
}

// Diff1Const returns the value of the "diff1_const" field in the mutation.
func (m *ChunithmMusicDifficultyMutation) Diff1Const() (r float64, exists bool) {
	v := m.diff1_const
	if v == nil {
		return
	}
	return *v, true
}

// OldDiff1Const returns the old "diff1_const" field's value of the ChunithmMusicDifficulty entity.
// If the ChunithmMusicDifficulty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicDifficultyMutation) OldDiff1Const(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiff1Const is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiff1Const requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiff1Const: %w", err)
	}
	return oldValue.Diff1Const, nil
}

// AddDiff1Const adds f to the "diff1_const" field.
func (m *ChunithmMusicDifficultyMutation) AddDiff1Const(f float64) {
	if m.adddiff1_const != nil {
		*m.adddiff1_const += f
	} else {
		m.adddiff1_const = &f
	}
}

// AddedDiff1Const returns the value that was added to the "diff1_const" field in this mutation.
func (m *ChunithmMusicDifficultyMutation) AddedDiff1Const() (r float64, exists bool) {
	v := m.adddiff1_const
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiff1Const clears the value of the "diff1_const" field.
func (m *ChunithmMusicDifficultyMutation) ClearDiff1Const() {
	m.diff1_const = nil
	m.adddiff1_const = nil
	m.clearedFields[chunithmmusicdifficulty.FieldDiff1Const] = struct{}{}
}

// Diff1ConstCleared returns if the "diff1_const" field was cleared in this mutation.
func (m *ChunithmMusicDifficultyMutation) Diff1ConstCleared() bool {
	_, ok := m.clearedFields[chunithmmusicdifficulty.FieldDiff1Const]
	return ok
}

// ResetDiff1Const resets all changes to the "diff1_const" field.
func (m *ChunithmMusicDifficultyMutation) ResetDiff1Const() {
	m.diff1_const = nil
	m.adddiff1_const = nil
	delete(m.clearedFields, chunithmmusicdifficulty.FieldDiff1Const)
}

// SetDiff2Const sets the "diff2_const" field.
func (m *ChunithmMusicDifficultyMutation) SetDiff2Const(f float64) {
	m.diff2_const = &f
	m.adddiff2_const = nil
}

// Diff2Const returns the value of the "diff2_const" field in the mutation.
func (m *ChunithmMusicDifficultyMutation) Diff2Const() (r float64, exists bool) {
	v := m.diff2_const
	if v == nil {
		return
	}
	return *v, true
}

// OldDiff2Const returns the old "diff2_const" field's value of the ChunithmMusicDifficulty entity.
// If the ChunithmMusicDifficulty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicDifficultyMutation) OldDiff2Const(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiff2Const is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiff2Const requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiff2Const: %w", err)
	}
	return oldValue.Diff2Const, nil
}

// AddDiff2Const adds f to the "diff2_const" field.
func (m *ChunithmMusicDifficultyMutation) AddDiff2Const(f float64) {
	if m.adddiff2_const != nil {
		*m.adddiff2_const += f
	} else {
		m.adddiff2_const = &f
	}
}

// AddedDiff2Const returns the value that was added to the "diff2_const" field in this mutation.
func (m *ChunithmMusicDifficultyMutation) AddedDiff2Const() (r float64, exists bool) {
	v := m.adddiff2_const
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiff2Const clears the value of the "diff2_const" field.
func (m *ChunithmMusicDifficultyMutation) ClearDiff2Const() {
	m.diff2_const = nil
	m.adddiff2_const = nil
	m.clearedFields[chunithmmusicdifficulty.FieldDiff2Const] = struct{}{}
}

// Diff2ConstCleared returns if the "diff2_const" field was cleared in this mutation.
func (m *ChunithmMusicDifficultyMutation) Diff2ConstCleared() bool {
	_, ok := m.clearedFields[chunithmmusicdifficulty.FieldDiff2Const]
	return ok
}

// ResetDiff2Const resets all changes to the "diff2_const" field.
func (m *ChunithmMusicDifficultyMutation) ResetDiff2Const() {
	m.diff2_const = nil
	m.adddiff2_const = nil
	delete(m.clearedFields, chunithmmusicdifficulty.FieldDiff2Const)
}

// SetDiff3Const sets the "diff3_const" field.
func (m *ChunithmMusicDifficultyMutation) SetDiff3Const(f float64) {
	m.diff3_const = &f
	m.adddiff3_const = nil
}

// Diff3Const returns the value of the "diff3_const" field in the mutation.
func (m *ChunithmMusicDifficultyMutation) Diff3Const() (r float64, exists bool) {
	v := m.diff3_const
	if v == nil {
		return
	}
	return *v, true
}

// OldDiff3Const returns the old "diff3_const" field's value of the ChunithmMusicDifficulty entity.
// If the ChunithmMusicDifficulty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicDifficultyMutation) OldDiff3Const(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiff3Const is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiff3Const requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiff3Const: %w", err)
	}
	return oldValue.Diff3Const, nil
}

// AddDiff3Const adds f to the "diff3_const" field.
func (m *ChunithmMusicDifficultyMutation) AddDiff3Const(f float64) {
	if m.adddiff3_const != nil {
		*m.adddiff3_const += f
	} else {
		m.adddiff3_const = &f
	}
}

// AddedDiff3Const returns the value that was added to the "diff3_const" field in this mutation.
func (m *ChunithmMusicDifficultyMutation) AddedDiff3Const() (r float64, exists bool) {
	v := m.adddiff3_const
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiff3Const clears the value of the "diff3_const" field.
func (m *ChunithmMusicDifficultyMutation) ClearDiff3Const() {
	m.diff3_const = nil
	m.adddiff3_const = nil
	m.clearedFields[chunithmmusicdifficulty.FieldDiff3Const] = struct{}{}
}

// Diff3ConstCleared returns if the "diff3_const" field was cleared in this mutation.
func (m *ChunithmMusicDifficultyMutation) Diff3ConstCleared() bool {
	_, ok := m.clearedFields[chunithmmusicdifficulty.FieldDiff3Const]
	return ok
}

// ResetDiff3Const resets all changes to the "diff3_const" field.
func (m *ChunithmMusicDifficultyMutation) ResetDiff3Const() {
	m.diff3_const = nil
	m.adddiff3_const = nil
	delete(m.clearedFields, chunithmmusicdifficulty.FieldDiff3Const)
}

// SetDiff4Const sets the "diff4_const" field.
func (m *ChunithmMusicDifficultyMutation) SetDiff4Const(f float64) {
	m.diff4_const = &f
	m.adddiff4_const = nil
}

// Diff4Const returns the value of the "diff4_const" field in the mutation.
func (m *ChunithmMusicDifficultyMutation) Diff4Const() (r float64, exists bool) {
	v := m.diff4_const
	if v == nil {
		return
	}
	return *v, true
}

// OldDiff4Const returns the old "diff4_const" field's value of the ChunithmMusicDifficulty entity.
// If the ChunithmMusicDifficulty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChunithmMusicDifficultyMutation) OldDiff4Const(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiff4Const is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiff4Const requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiff4Const: %w", err)
	}
	return oldValue.Diff4Const, nil
}

// AddDiff4Const adds f to the "diff4_const" field.
func (m *ChunithmMusicDifficultyMutation) AddDiff4Const(f float64) {
	if m.adddiff4_const != nil {
		*m.adddiff4_const += f
	} else {
		m.adddiff4_const = &f
	}
}

// AddedDiff4Const returns the value that was added to the "diff4_const" field in this mutation.
func (m *ChunithmMusicDifficultyMutation) AddedDiff4Const() (r float64, exists bool) {
	v := m.adddiff4_const
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiff4Const clears the value of the "diff4_const" field.
func (m *ChunithmMusicDifficultyMutation) ClearDiff4Const() {
	m.diff4_const = nil
	m.adddiff4_const = nil
	m.clearedFields[chunithmmusicdifficulty.FieldDiff4Const] = struct{}{}
}

// Diff4ConstCleared returns if the "diff4_const" field was cleared in this mutation.
func (m *ChunithmMusicDifficultyMutation) Diff4ConstCleared() bool {
	_, ok := m.clearedFields[chunithmmusicdifficulty.FieldDiff4Const]
	return ok
}

// ResetDiff4Const resets all changes to the "diff4_const" field.
func (m *ChunithmMusicDifficultyMutation) ResetDiff4Const() {
	m.diff4_const = nil
	m.adddiff4_const = nil
	delete(m.clearedFields, chunithmmusicdifficulty.FieldDiff4Const)
}

// Where appends a list predicates to the ChunithmMusicDifficultyMutation builder.
func (m *ChunithmMusicDifficultyMutation) Where(ps ...predicate.ChunithmMusicDifficulty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChunithmMusicDifficultyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChunithmMusicDifficultyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChunithmMusicDifficulty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChunithmMusicDifficultyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChunithmMusicDifficultyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChunithmMusicDifficulty).
func (m *ChunithmMusicDifficultyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChunithmMusicDifficultyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.music_id != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldMusicID)
	}
	if m.version != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldVersion)
	}
	if m.diff0_const != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff0Const)
	}
	if m.diff1_const != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff1Const)
	}
	if m.diff2_const != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff2Const)
	}
	if m.diff3_const != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff3Const)
	}
	if m.diff4_const != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff4Const)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChunithmMusicDifficultyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chunithmmusicdifficulty.FieldMusicID:
		return m.MusicID()
	case chunithmmusicdifficulty.FieldVersion:
		return m.Version()
	case chunithmmusicdifficulty.FieldDiff0Const:
		return m.Diff0Const()
	case chunithmmusicdifficulty.FieldDiff1Const:
		return m.Diff1Const()
	case chunithmmusicdifficulty.FieldDiff2Const:
		return m.Diff2Const()
	case chunithmmusicdifficulty.FieldDiff3Const:
		return m.Diff3Const()
	case chunithmmusicdifficulty.FieldDiff4Const:
		return m.Diff4Const()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChunithmMusicDifficultyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chunithmmusicdifficulty.FieldMusicID:
		return m.OldMusicID(ctx)
	case chunithmmusicdifficulty.FieldVersion:
		return m.OldVersion(ctx)
	case chunithmmusicdifficulty.FieldDiff0Const:
		return m.OldDiff0Const(ctx)
	case chunithmmusicdifficulty.FieldDiff1Const:
		return m.OldDiff1Const(ctx)
	case chunithmmusicdifficulty.FieldDiff2Const:
		return m.OldDiff2Const(ctx)
	case chunithmmusicdifficulty.FieldDiff3Const:
		return m.OldDiff3Const(ctx)
	case chunithmmusicdifficulty.FieldDiff4Const:
		return m.OldDiff4Const(ctx)
	}
	return nil, fmt.Errorf("unknown ChunithmMusicDifficulty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChunithmMusicDifficultyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chunithmmusicdifficulty.FieldMusicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicID(v)
		return nil
	case chunithmmusicdifficulty.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case chunithmmusicdifficulty.FieldDiff0Const:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiff0Const(v)
		return nil
	case chunithmmusicdifficulty.FieldDiff1Const:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiff1Const(v)
		return nil
	case chunithmmusicdifficulty.FieldDiff2Const:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiff2Const(v)
		return nil
	case chunithmmusicdifficulty.FieldDiff3Const:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiff3Const(v)
		return nil
	case chunithmmusicdifficulty.FieldDiff4Const:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiff4Const(v)
		return nil
	}
	return fmt.Errorf("unknown ChunithmMusicDifficulty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChunithmMusicDifficultyMutation) AddedFields() []string {
	var fields []string
	if m.addmusic_id != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldMusicID)
	}
	if m.adddiff0_const != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff0Const)
	}
	if m.adddiff1_const != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff1Const)
	}
	if m.adddiff2_const != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff2Const)
	}
	if m.adddiff3_const != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff3Const)
	}
	if m.adddiff4_const != nil {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff4Const)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChunithmMusicDifficultyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chunithmmusicdifficulty.FieldMusicID:
		return m.AddedMusicID()
	case chunithmmusicdifficulty.FieldDiff0Const:
		return m.AddedDiff0Const()
	case chunithmmusicdifficulty.FieldDiff1Const:
		return m.AddedDiff1Const()
	case chunithmmusicdifficulty.FieldDiff2Const:
		return m.AddedDiff2Const()
	case chunithmmusicdifficulty.FieldDiff3Const:
		return m.AddedDiff3Const()
	case chunithmmusicdifficulty.FieldDiff4Const:
		return m.AddedDiff4Const()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChunithmMusicDifficultyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chunithmmusicdifficulty.FieldMusicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMusicID(v)
		return nil
	case chunithmmusicdifficulty.FieldDiff0Const:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiff0Const(v)
		return nil
	case chunithmmusicdifficulty.FieldDiff1Const:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiff1Const(v)
		return nil
	case chunithmmusicdifficulty.FieldDiff2Const:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiff2Const(v)
		return nil
	case chunithmmusicdifficulty.FieldDiff3Const:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiff3Const(v)
		return nil
	case chunithmmusicdifficulty.FieldDiff4Const:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiff4Const(v)
		return nil
	}
	return fmt.Errorf("unknown ChunithmMusicDifficulty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChunithmMusicDifficultyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chunithmmusicdifficulty.FieldDiff0Const) {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff0Const)
	}
	if m.FieldCleared(chunithmmusicdifficulty.FieldDiff1Const) {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff1Const)
	}
	if m.FieldCleared(chunithmmusicdifficulty.FieldDiff2Const) {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff2Const)
	}
	if m.FieldCleared(chunithmmusicdifficulty.FieldDiff3Const) {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff3Const)
	}
	if m.FieldCleared(chunithmmusicdifficulty.FieldDiff4Const) {
		fields = append(fields, chunithmmusicdifficulty.FieldDiff4Const)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChunithmMusicDifficultyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChunithmMusicDifficultyMutation) ClearField(name string) error {
	switch name {
	case chunithmmusicdifficulty.FieldDiff0Const:
		m.ClearDiff0Const()
		return nil
	case chunithmmusicdifficulty.FieldDiff1Const:
		m.ClearDiff1Const()
		return nil
	case chunithmmusicdifficulty.FieldDiff2Const:
		m.ClearDiff2Const()
		return nil
	case chunithmmusicdifficulty.FieldDiff3Const:
		m.ClearDiff3Const()
		return nil
	case chunithmmusicdifficulty.FieldDiff4Const:
		m.ClearDiff4Const()
		return nil
	}
	return fmt.Errorf("unknown ChunithmMusicDifficulty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChunithmMusicDifficultyMutation) ResetField(name string) error {
	switch name {
	case chunithmmusicdifficulty.FieldMusicID:
		m.ResetMusicID()
		return nil
	case chunithmmusicdifficulty.FieldVersion:
		m.ResetVersion()
		return nil
	case chunithmmusicdifficulty.FieldDiff0Const:
		m.ResetDiff0Const()
		return nil
	case chunithmmusicdifficulty.FieldDiff1Const:
		m.ResetDiff1Const()
		return nil
	case chunithmmusicdifficulty.FieldDiff2Const:
		m.ResetDiff2Const()
		return nil
	case chunithmmusicdifficulty.FieldDiff3Const:
		m.ResetDiff3Const()
		return nil
	case chunithmmusicdifficulty.FieldDiff4Const:
		m.ResetDiff4Const()
		return nil
	}
	return fmt.Errorf("unknown ChunithmMusicDifficulty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChunithmMusicDifficultyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChunithmMusicDifficultyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChunithmMusicDifficultyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChunithmMusicDifficultyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChunithmMusicDifficultyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChunithmMusicDifficultyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChunithmMusicDifficultyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ChunithmMusicDifficulty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChunithmMusicDifficultyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ChunithmMusicDifficulty edge %s", name)
}
